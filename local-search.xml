<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Flutter GetX 实现 ChatGPT 简单聊天界面</title>
    <link href="/2023/03/24/Flutter-GetX-%E5%AE%9E%E7%8E%B0-ChatGPT-%E7%AE%80%E5%8D%95%E8%81%8A%E5%A4%A9%E7%95%8C%E9%9D%A2/"/>
    <url>/2023/03/24/Flutter-GetX-%E5%AE%9E%E7%8E%B0-ChatGPT-%E7%AE%80%E5%8D%95%E8%81%8A%E5%A4%A9%E7%95%8C%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<p><strong>Flutter 是一款跨平台的移动应用开发框架，而 GetX 是 Flutter 中一种简单易用的状态管理和路由管理工具。本篇我们将使用 Flutter 和 GetX 实现一个简单的聊天界面，以与 ChatGPT 进行交互。</strong></p><p>我们需要在 Flutter 项目中引入 GetX 库。在<code>pubspec.yaml</code>文件中添加以下依赖：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">dependencies:</span><br><span class="hljs-symbol">  flutter:</span><br><span class="hljs-symbol">    sdk:</span> flutter<br><span class="hljs-symbol">  get:</span> <br><br></code></pre></td></tr></table></figure><p>在<code>main</code>函数中添加以下代码：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">void <span class="hljs-selector-tag">main</span>() &#123;<br>  <span class="hljs-comment">//在main函数第一行添加这句话</span><br>  WidgetsFlutterBinding<span class="hljs-selector-class">.ensureInitialized</span>();<br>  <span class="hljs-built_in">runApp</span>(GetMaterialApp(<br>    home: ChatPage(),<br>  ));<br>&#125;<br></code></pre></td></tr></table></figure><p>确保<code>Flutter Widgets</code>已经初始化，并且启动应用程序的<code>ChatPage</code>页面。</p><p>接下来，我们需要创建一个<code>ApiProvider</code>类，用于与 OpenAI API 进行交互。这个类继承自<code>GetConnect</code>，<code>GetConnect</code>是一个轻量级的 HTTP 客户端，它能够简化与 API 的通信过程。以下是<code>ApiProvider</code>类的代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GetConnect</span> </span>&#123;<br><br>  <span class="hljs-comment">/// <span class="language-markdown">这里填写自己OpenAI API Key</span></span><br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> apiKey = <span class="hljs-string">&#x27;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&#x27;</span>;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> baseUrl = <span class="hljs-string">&#x27;https://api.openai.com&#x27;</span>;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">Duration</span> timeout = <span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">30</span>);<br><br>  <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>&gt; _headers() &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>,<br>      <span class="hljs-string">&#x27;Authorization&#x27;</span>: <span class="hljs-string">&#x27;Bearer <span class="hljs-subst">$apiKey</span>&#x27;</span>,<br>    &#125;;<br>  &#125;<br><br>  ApiProvider() &#123;<br>    httpClient.baseUrl = baseUrl;<br>    httpClient.timeout = timeout;<br>    httpClient.addAuthenticator((request)  &#123;<br>      request.headers.addAll(_headers());<br>      <span class="hljs-keyword">return</span> request;<br>    &#125;);<br>  &#125;<br><br>  Future&lt;Response&gt; completions(<span class="hljs-built_in">String</span> body) &#123;<br>    <span class="hljs-keyword">return</span> post(<span class="hljs-string">&#x27;/v1/chat/completions&#x27;</span>, body);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个类中，我们设置了 API 的基础 URL 和超时时间，并实现了 HTTP 请求的授权和身份验证。我们还实现了<code>completions</code>方法，用于向 OpenAI API 发送请求并获取聊天机器人的回复。注意这里需要设置自己账号的API KEY， 地址： <a href="https://platform.openai.com/account/api-keys">https://platform.openai.com/account/api-keys</a></p><p>接下来，我们需要创建一个<code>ChatLogic</code>类，用于处理聊天机器人的逻辑。以下是<code>ChatLogic类</code>的代码：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs pf">class ChatLogic extends GetxController &#123;<br>  final ChatState <span class="hljs-keyword">state</span> = ChatState();<br>  final ApiProvider provider = ApiProvider();<br><br>  Future<span class="hljs-variable">&lt;void&gt;</span> sendMessage(String content) async &#123;<br>    <span class="hljs-keyword">state</span>.requestStatus(content);<br>    update();<br>    final response = await provider.completions(json.encode(&#123;<br>      <span class="hljs-string">&quot;model&quot;</span>: <span class="hljs-string">&quot;gpt-3.5-turbo&quot;</span>,<br>      <span class="hljs-string">&quot;messages&quot;</span>: [&#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;$content&quot;</span>&#125;]<br>    &#125;));<br>    try &#123;<br>      if(response.statusCode == <span class="hljs-number">200</span>) &#123;<br>        final data = response.body;<br>        final text = data[&#x27;choices&#x27;][<span class="hljs-number">0</span>][&#x27;message&#x27;][&#x27;content&#x27;];<br>        <span class="hljs-keyword">state</span>.responseStatus(text);<br>      &#125; else &#123;<br>        <span class="hljs-keyword">state</span>.responseStatus(response.statusText ?? &#x27;请求错误，请稍后重试&#x27;);<br>      &#125;<br>    &#125; catch(error) &#123;<br>      <span class="hljs-keyword">state</span>.responseStatus(error.<span class="hljs-keyword">to</span>String());<br>    &#125;<br>    update();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个类中，我们创建了一个<code>sendMessage</code>方法，该方法接收用户的消息并发送给 OpenAI API，然后等待 API 返回响应。在收到响应后，我们将从 API 返回的 JSON 数据中提取出回复消息的内容，并将其更新到<code>ChatState</code>状态类的<code>messages</code>列表中，然后在 UI 中显示。</p><p>接下来，我们需要创建一个<code>ChatState</code>类来管理我们的应用程序状态。以下是<code>ChatState</code>类的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChatState</span> &#123;<br><br>  <span class="hljs-title class_">String</span> message = <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-title class_">String</span> sender = <span class="hljs-string">&#x27;user&#x27;</span>;<br>  bool isRequesting = <span class="hljs-literal">false</span>;<br>  <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, dynamic&gt;&gt; messages = [];<br><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">requestStatus</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> content</span>) &#123;<br>    messages.<span class="hljs-title function_">add</span>(&#123;<span class="hljs-string">&#x27;text&#x27;</span>: content, <span class="hljs-string">&#x27;sender&#x27;</span>: <span class="hljs-string">&#x27;user&#x27;</span>&#125;);<br>    sender = <span class="hljs-string">&#x27;bot&#x27;</span>;<br>    messages.<span class="hljs-title function_">add</span>(&#123;<span class="hljs-string">&#x27;text&#x27;</span>: <span class="hljs-string">&#x27;正在回复中...&#x27;</span>, <span class="hljs-string">&#x27;sender&#x27;</span>: sender&#125;);<br>    isRequesting = <span class="hljs-literal">true</span>;<br>    message = <span class="hljs-string">&#x27;&#x27;</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">responseStatus</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> content</span>) &#123;<br>    messages.<span class="hljs-title function_">removeLast</span>(); <span class="hljs-comment">// Remove &quot;正在回复中...&quot; 状态</span><br>    messages.<span class="hljs-title function_">add</span>(&#123;<span class="hljs-string">&#x27;text&#x27;</span>: content, <span class="hljs-string">&#x27;sender&#x27;</span>: sender&#125;);<br>    sender = <span class="hljs-string">&#x27;user&#x27;</span>;<br>    isRequesting = <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个类中，存储了聊天应用程序的状态信息，包括消息、发送者、请求状态和历史消息列表。<code>requestStatus()</code>方法用于更新状态以反映正在发送消息的状态，<code>responseStatus()</code>方法用于更新状态以反映接收到的消息。</p><p>最后，我们定义了<code>ChatPage</code>类，它继承自<code>StatelessWidget</code>，它将用于展示聊天对话框。以下是<code>ChatPage</code>类的代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChatPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-title function_ invoke__">ChatPage</span>(&#123;Key? key&#125;) : <span class="hljs-title function_ invoke__">super</span>(<span class="hljs-attr">key</span>: key);<br><br>  <span class="hljs-keyword">final</span> logic = Get.<span class="hljs-title function_ invoke__">put</span>(<span class="hljs-title function_ invoke__">ChatLogic</span>());<br>  <span class="hljs-keyword">final</span> state = Get.find&lt;ChatLogic&gt;().state;<br><br>  @override<br>  Widget <span class="hljs-title function_ invoke__">build</span>(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Scaffold</span>(<br>      <span class="hljs-attr">appBar</span>: <span class="hljs-title function_ invoke__">AppBar</span>(<br>        <span class="hljs-attr">centerTitle</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">title</span>: <span class="hljs-title function_ invoke__">Text</span>(<span class="hljs-string">&#x27;你问我答&#x27;</span>),<br>      ),<br>      <span class="hljs-attr">body</span>: GetBuilder&lt;ChatLogic&gt;(<br>        <span class="hljs-attr">builder</span>: (context) =&gt; <span class="hljs-title function_ invoke__">Column</span>(<br>          <span class="hljs-attr">children</span>: [<br>            <span class="hljs-title function_ invoke__">Expanded</span>(<br>              <span class="hljs-attr">child</span>: ListView.<span class="hljs-title function_ invoke__">builder</span>(<br>                <span class="hljs-attr">itemCount</span>: state.messages.length,<br>                <span class="hljs-attr">itemBuilder</span>: (BuildContext context, <span class="hljs-keyword">int</span> index) &#123;<br>                  Map m = state.messages[index];<br>                  <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Padding</span>(<br>                    <span class="hljs-attr">padding</span>: <span class="hljs-keyword">const</span> EdgeInsets.<span class="hljs-title function_ invoke__">all</span>(<span class="hljs-number">8.0</span>),<br>                    <span class="hljs-attr">child</span>: <span class="hljs-title function_ invoke__">Row</span>(<br>                      <span class="hljs-attr">mainAxisAlignment</span>: m[<span class="hljs-string">&#x27;sender&#x27;</span>] == <span class="hljs-string">&#x27;user&#x27;</span><br>                          ? MainAxisAlignment.end<br>                          : MainAxisAlignment.start,<br>                      <span class="hljs-attr">children</span>: [<br>                        <span class="hljs-title function_ invoke__">Flexible</span>(<br>                          <span class="hljs-attr">child</span>: <span class="hljs-title function_ invoke__">Container</span>(<br>                            <span class="hljs-attr">padding</span>: <span class="hljs-keyword">const</span> EdgeInsets.<span class="hljs-title function_ invoke__">all</span>(<span class="hljs-number">8.0</span>),<br>                            <span class="hljs-attr">decoration</span>: <span class="hljs-title function_ invoke__">BoxDecoration</span>(<br>                              <span class="hljs-attr">borderRadius</span>: BorderRadius.<span class="hljs-title function_ invoke__">circular</span>(<span class="hljs-number">8.0</span>),<br>                              <span class="hljs-attr">color</span>: m[<span class="hljs-string">&#x27;sender&#x27;</span>] == <span class="hljs-string">&#x27;user&#x27;</span><br>                                  ? Colors.green[<span class="hljs-number">100</span>]<br>                                  : Colors.white,<br>                            ),<br>                            <span class="hljs-attr">child</span>: <span class="hljs-title function_ invoke__">Text</span>(m[<span class="hljs-string">&#x27;text&#x27;</span>]),<br>                          ),<br>                        )<br>                      ],<br>                    ),<br>                  );<br>                &#125;,<br>              ),<br>            ),<br>            <span class="hljs-title function_ invoke__">Container</span>(<br>              <span class="hljs-attr">decoration</span>: <span class="hljs-title function_ invoke__">BoxDecoration</span>(<br>                <span class="hljs-attr">color</span>: Colors.white,<br>                <span class="hljs-attr">borderRadius</span>: BorderRadius.<span class="hljs-title function_ invoke__">only</span>(<br>                  <span class="hljs-attr">topLeft</span>: Radius.<span class="hljs-title function_ invoke__">circular</span>(<span class="hljs-number">12.0</span>),<br>                  <span class="hljs-attr">topRight</span>: Radius.<span class="hljs-title function_ invoke__">circular</span>(<span class="hljs-number">12.0</span>),<br>                ),<br>              ),<br>              <span class="hljs-attr">child</span>: <span class="hljs-title function_ invoke__">Row</span>(<br>                <span class="hljs-attr">children</span>: [<br>                  <span class="hljs-title function_ invoke__">Expanded</span>(<br>                    <span class="hljs-attr">child</span>: <span class="hljs-title function_ invoke__">Padding</span>(<br>                      <span class="hljs-attr">padding</span>: <span class="hljs-keyword">const</span> EdgeInsets.<span class="hljs-title function_ invoke__">all</span>(<span class="hljs-number">8.0</span>),<br>                      <span class="hljs-attr">child</span>: <span class="hljs-title function_ invoke__">TextField</span>(<br>                          <span class="hljs-attr">decoration</span>: <span class="hljs-title function_ invoke__">InputDecoration</span>(<br>                            <span class="hljs-attr">hintText</span>: <span class="hljs-string">&#x27;请输入消息&#x27;</span>,<br>                            <span class="hljs-attr">border</span>: InputBorder.none,<br>                          ),<br>                          <span class="hljs-attr">controller</span>:<br>                              <span class="hljs-title function_ invoke__">TextEditingController</span>(<span class="hljs-attr">text</span>: state.message),<br>                          <span class="hljs-attr">onChanged</span>: (value) &#123;<br>                            state.message = value;<br>                          &#125;),<br>                    ),<br>                  ),<br>                  <span class="hljs-title function_ invoke__">IconButton</span>(<br>                    <span class="hljs-attr">icon</span>: <span class="hljs-title function_ invoke__">Icon</span>(Icons.send),<br>                    <span class="hljs-attr">onPressed</span>: state.isRequesting<br>                        ? <span class="hljs-literal">null</span><br>                        : () &#123;<br>                            logic.<span class="hljs-title function_ invoke__">sendMessage</span>(state.message);<br>                          &#125;,<br>                  ),<br>                ],<br>              ),<br>            ),<br>          ],<br>        ),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该类包含一个<code>ChatLogic</code>实例和一个<code>ChatState</code>实例。在<code>build()</code>方法中，我们使用<code>GetBuilder</code>包装整个聊天界面。这个界面包括一个消息列表和一个输入框，用户可以在其中输入消息并发送给聊天机器人。<code>ListView.builder</code>用于显示历史消息，<code>TextField</code>和<code>IconButton</code>用于接收用户输入并发送消息。在发送消息之前，会检查当前状态是否为请求状态，以避免重复发送请求。</p><p><strong>到这里一个简单的聊天功能就完成了，运行下看看效果吧：</strong></p><p><img src="openai_chat_demo.gif" alt="openai_chat_demo"></p><p><strong>综上所述，本篇介绍了一个使用 Flutter 和 OpenAI API 实现的基于 GPT-3 的聊天机器人。通过实现<code>ApiProvider、ChatLogic</code>和<code>ChatState</code>类，我们能够将 OpenAI API 的功能集成到 Flutter 应用程序中，并实现一个基本的聊天界面。感兴趣的小伙们可以自己试试哈，Demo地址：<a href="https://github.com/smallmarker/OpenAIChat">https://github.com/smallmarker/OpenAIChat</a></strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Retrofit 核心源码分析（三）- Call 逻辑分析和扩展机制</title>
    <link href="/2023/03/10/Retrofit%20%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89-Call-%E9%80%BB%E8%BE%91%E5%88%86%E6%9E%90%E5%92%8C%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/03/10/Retrofit%20%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89-Call-%E9%80%BB%E8%BE%91%E5%88%86%E6%9E%90%E5%92%8C%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p><strong>在前面的两篇文章中，我们已经对 Retrofit 的注解解析、动态代理、网络请求和响应处理机制有了一定的了解。在这篇文章中，我们将深入分析 Retrofit 的 Call 逻辑，并介绍 Retrofit 的扩展机制。</strong></p><h3 id="一、Call-逻辑分析"><a href="#一、Call-逻辑分析" class="headerlink" title="一、Call 逻辑分析"></a>一、Call 逻辑分析</h3><p>Call 是 Retrofit 中最基本的操作单元，它代表一个 HTTP 请求。在 Retrofit 中，我们通过接口定义请求的方式，并通过动态代理生成接口的实现类。这个实现类中的方法都会返回一个 Call 对象，通过这个对象我们可以发起网络请求，并获得响应结果。</p><p>Retrofit 的 Call 逻辑可以用以下代码来描述：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Call</span>&lt;<span class="hljs-title">T</span>&gt; &#123;<br>    <span class="hljs-function">Response&lt;T&gt; <span class="hljs-title">execute</span>() throws IOException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span>(<span class="hljs-params">Callback&lt;T&gt; callback</span>)</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cancel</span>()</span>;<br>    <span class="hljs-function">boolean <span class="hljs-title">isExecuted</span>()</span>;<br>    <span class="hljs-function">boolean <span class="hljs-title">isCanceled</span>()</span>;<br>    <span class="hljs-function">Call&lt;T&gt; <span class="hljs-title">clone</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个接口中，我们可以看到 Retrofit 定义了五个方法，分别是 <code>execute</code>、<code>enqueue</code>、<code>cancel</code>、<code>isExecuted</code>和<code>isCanceled</code>。我们来逐一分析这些方法的作用。</p><h4 id="execute-方法"><a href="#execute-方法" class="headerlink" title="execute 方法"></a>execute 方法</h4><p><code>execute</code>方法用于同步发起 HTTP 请求，当我们调用<code>execute()</code>方法时，它会立即发起网络请求，并且阻塞当前线程直到请求结束，最后返回一个响应对象<code>Response</code>。这种方式适用于简单的网络请求，但不适合于在主线程中执行请求，因为会阻塞 UI 线程。</p><p>以下是<code>execute()</code>方法的部分代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Response&lt;T&gt; <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>  <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>    <span class="hljs-keyword">if</span> (executed) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Already executed.&quot;</span>);<br>    executed = <span class="hljs-literal">true</span>;<br>  &#125;<br>  captureCallStackTrace();<br>  <span class="hljs-keyword">try</span> &#123;<br>    client.dispatcher().executed(<span class="hljs-built_in">this</span>);<br>    Response&lt;T&gt; result = getResponseWithInterceptorChain();<br>    <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;Canceled&quot;</span>);<br>    <span class="hljs-keyword">return</span> result;<br>  &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    <span class="hljs-keyword">throw</span> timeoutExit(e);<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    client.dispatcher().finished(<span class="hljs-built_in">this</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，我们可以看到该方法首先会检查当前请求是否已经执行过，如果已经执行过则会抛出一个异常。然后会将该请求加入到<code>Dispatcher</code>中的执行队列中。接下来会调用<code>getResponseWithInterceptorChain()</code>方法来获取响应结果。如果结果为null，则表示请求已经被取消，否则返回响应结果。最后，会将该请求从执行队列中移除。</p><h4 id="enqueue-方法"><a href="#enqueue-方法" class="headerlink" title="enqueue 方法"></a>enqueue 方法</h4><p><code>enqueue</code>方法用于异步发起 HTTP 请求，它会在后台线程中发起网络请求，并在请求结束后将结果返回到主线程中。因此，<code>enqueue()</code>方法适用于在主线程中执行网络请求。</p><p>以下是<code>enqueue()</code>方法的部分代码：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(Callback&lt;T&gt; callback)</span> </span>&#123;<br>  <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>    <span class="hljs-keyword">if</span> (executed) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Already executed.&quot;</span>);<br>    executed = <span class="hljs-keyword">true</span>;<br>  &#125;<br>  captureCallStackTrace();<br>  client.dispatcher().enqueue(<span class="hljs-keyword">new</span> AsyncCall(callback));<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，我们可以看到该方法首先会检查当前请求是否已经执行过，如果已经执行过则会抛出一个异常。然后会将该请求封装成一个<code>AsyncCall</code>对象，加入到<code>Dispatcher</code>中的异步队列中。</p><p><code>AsyncCall</code>继承自<code>RealCall</code>，它实现了<code>Runnable</code>接口，表示可以在后台线程中执行。在<code>AsyncCall</code>中，我们可以看到它会在后台线程中执行网络请求，并将结果通过<code>Callback</code>回调返回到主线程中。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncCall</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RealCall</span>.<span class="hljs-title">AsyncCall</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Callback</span>&lt;<span class="hljs-type">T</span>&gt; responseCallback;<br><br>  <span class="hljs-type">AsyncCall</span>(<span class="hljs-type">Callback</span>&lt;<span class="hljs-type">T</span>&gt; responseCallback) &#123;<br>    <span class="hljs-keyword">super</span>();<br>    <span class="hljs-keyword">this</span>.responseCallback = responseCallback;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span> <span class="hljs-keyword">protected</span> void execute() &#123;<br>    boolean signalledCallback = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-type">Response</span>&lt;<span class="hljs-type">T</span>&gt; response = getResponseWithInterceptorChain();<br>      <span class="hljs-keyword">if</span> (retryAndFollowUpInterceptor.isCanceled()) &#123;<br>        signalledCallback = <span class="hljs-literal">true</span>;<br>        responseCallback.onFailure(<span class="hljs-type">RealCall</span>.<span class="hljs-keyword">this</span>, <span class="hljs-keyword">new</span> <span class="hljs-type">IOException</span>(<span class="hljs-string">&quot;Canceled&quot;</span>));<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        signalledCallback = <span class="hljs-literal">true</span>;<br>        responseCallback.onResponse(<span class="hljs-type">RealCall</span>.<span class="hljs-keyword">this</span>, response);<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-type">IOException</span> e) &#123;<br>      <span class="hljs-keyword">if</span> (signalledCallback) &#123;<br>        <span class="hljs-comment">// Do not signal the callback twice!</span><br>        <span class="hljs-type">Platform</span>.get().log(<span class="hljs-type">INFO</span>, <span class="hljs-string">&quot;Callback failure for &quot;</span> + toLoggableString(), e);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        responseCallback.onFailure(<span class="hljs-type">RealCall</span>.<span class="hljs-keyword">this</span>, e);<br>      &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      client.dispatcher().finished(<span class="hljs-keyword">this</span>);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span> public <span class="hljs-type">String</span> toString() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">RealCall</span>.<span class="hljs-keyword">this</span>.toString();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>AsyncCall</code>中，首先会调用<code>getResponseWithInterceptorChain()</code>方法来获取响应结果。如果请求被取消，则会调用<code>onFailure()</code>方法将结果返回到主线程中。否则，会调用<code>onResponse()</code>方法将结果返回到主线程中。无论请求成功或失败，都会调用<code>finished()</code>方法将该请求从异步队列中移除。</p><h4 id="cancel-方法"><a href="#cancel-方法" class="headerlink" title="cancel 方法"></a>cancel 方法</h4><p><code>cancel</code>方法用于取消正在执行的请求。如果请求已经完成或已经取消，则该方法不会有任何效果。</p><h4 id="isExecuted-方法"><a href="#isExecuted-方法" class="headerlink" title="isExecuted 方法"></a>isExecuted 方法</h4><p><code>isExecuted</code>方法用于判断请求是否已经执行。如果已经执行，则返回true，否则返回false。</p><h4 id="isCanceled-方法"><a href="#isCanceled-方法" class="headerlink" title="isCanceled 方法"></a>isCanceled 方法</h4><p><code>isCanceled</code>方法用于判断请求是否已经取消。如果已经取消，则返回true，否则返回false。</p><h4 id="clone-方法"><a href="#clone-方法" class="headerlink" title="clone 方法"></a>clone 方法</h4><p><code>clone</code>方法用于创建一个当前 Call 对象的副本。这个方法一般用于发起多次相同的请求。</p><p>以上这些方法就构成了 Retrofit 的 Call 逻辑。在使用 Retrofit 时，我们一般会通过<code>execute</code>或<code>enqueue</code>方法发起 HTTP 请求，并通过传入的<code>Callback</code>对象来处理响应结果。</p><h3 id="二、扩展机制"><a href="#二、扩展机制" class="headerlink" title="二、扩展机制"></a>二、扩展机制</h3><p>Retrofit 是一个非常灵活的网络请求库，它提供了很多扩展机制，让我们可以根据自己的需要来定制请求和响应处理逻辑。下面介绍一些常用的扩展机制。</p><h4 id="Converter"><a href="#Converter" class="headerlink" title="Converter"></a>Converter</h4><p>Converter 用于将 HTTP 请求和响应的数据类型转换成 Java 对象。Retrofit 默认提供了两种 Converter：<code>GsonConverter</code>和<code>JacksonConverter</code>，它们分别使用<code>Gson</code>和<code>Jackson</code>库将数据类型转换成<code>Java</code>对象。如果我们需要使用其他类型的转换库，也可以自定义 Converter 来实现。</p><p>下面是一个自定义 Converter 的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConverter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Converter</span>&lt;ResponseBody, MyObject&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> Gson gson;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyConverter</span><span class="hljs-params">(Gson gson)</span> &#123;<br>        <span class="hljs-built_in">this</span>.gson = gson;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> MyObject <span class="hljs-title function_">convert</span><span class="hljs-params">(ResponseBody value)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> value.string();<br>            <span class="hljs-type">MyObject</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> gson.fromJson(json, MyObject.class);<br>            <span class="hljs-keyword">return</span> obj;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            value.close();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的示例中，我们定义了一个<code>MyConverter</code>类，它实现了<code>Converter</code>接口，用于将<code>ResponseBody</code>类型的响应数据转换成<code>MyObject</code>类型的<code>Java</code>对象。在<code>convert</code>方法中，我们使用自己定义的转换逻辑来实现数据类型的转换。</p><h4 id="Interceptor"><a href="#Interceptor" class="headerlink" title="Interceptor"></a>Interceptor</h4><p>Interceptor 用于对 HTTP 请求进行拦截和处理。在 Retrofit 中，我们可以通过 Interceptor 来对请求添加头信息、对响应进行缓存、打印请求日志等操作。Retrofit 提供了两种 Interceptor：<code>OkHttpInterceptor</code>和<code>RetrofitInterceptor</code>，它们分别用于拦截 OkHttp 的请求和 Retrofit 的请求。我们也可以自定义 Interceptor 来实现自己的拦截逻辑。</p><p>下面是一个自定义 Interceptor 的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Response <span class="hljs-title function_">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 在这里可以对请求进行拦截和处理</span><br>        <span class="hljs-type">Request</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> chain.request();<br>        <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> chain.proceed(request);<br>        <span class="hljs-comment">// 在这里可以对响应进行处理</span><br>        <span class="hljs-keyword">return</span> response;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的示例中，我们定义了一个<code>MyInterceptor</code>类，它实现了<code>Interceptor</code>接口，用于对请求和响应进行拦截和处理。在<code>intercept</code>方法中，我们可以对请求进行处理，然后使用<code>chain.proceed(request)</code>方法将请求传递给下一个拦截器或处理器，最终获得响应结果并进行处理。</p><h4 id="CallAdapter"><a href="#CallAdapter" class="headerlink" title="CallAdapter"></a>CallAdapter</h4><p>CallAdapter 用于将 Call 对象转换成另一种类型的对象。在 Retrofit 中，我们可以通过 CallAdapter 将 Call 对象转换成 RxJava 的 Observable 对象，也可以将 Call 对象转换成 LiveData 对象。Retrofit 提供了两种CallAdapter：<code>RxJavaCallAdapter</code>和<code>LiveDataCallAdapter</code>，它们分别用于将 Call 对象转换成 RxJava 的 Observable 对象和 LiveData 对象。我们也可以自定义 CallAdapter 来实现自己的转换逻辑。</p><p>下面是一个自定义 CallAdapter 的示例：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCallAdapter</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">CallAdapter</span></span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">MyResult</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;<br>    @Override<br>    <span class="hljs-keyword">public</span> Type responseType() &#123;<br>        <span class="hljs-comment">// 返回响应数据的类型</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">ParameterizedTypeImpl</span>(MyResult.class, <span class="hljs-keyword">new</span> <span class="hljs-type">Type</span>[]&#123;T.class&#125;);<br>    &#125;<br><br>    @Override<br>    <span class="hljs-keyword">public</span> MyResult&lt;T&gt; adapt(Call&lt;T&gt; call) &#123;<br>        <span class="hljs-comment">// 在这里可以对Call对象进行处理，并返回自定义的结果对象</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Response&lt;T&gt; response = call.execute();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">MyResult</span>&lt;&gt;(response.body(), response.code(), response.message());<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">MyResult</span>&lt;&gt;(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的示例中，我们定义了一个<code>MyCallAdapter</code>类，它实现了<code>CallAdapter</code>接口，用于将<code>Call</code>对象转换成<code>MyResult</code>对象。在<code>responseType</code>方法中，我们返回了响应数据的类型，它是一个<code>ParameterizedTypeImpl</code>类型的对象，用于表示<code>MyResult&lt;T&gt;</code>类型。在<code>adapt</code>方法中，我们对<code>Call</code>对象进行处理，并返回自定义的<code>MyResult</code>对象，它包含了响应数据、状态码和错误信息。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>在本文中，我们深入分析了 Retrofit 的核心源码，特别是 Call 逻辑的实现细节，以及 Retrofit 的三个扩展机制：Converter、Interceptor 和 CallAdapter。</strong></p><p><strong>通过本文的学习，我们可以更加深入地理解 Retrofit 的工作原理，并可以根据需求自定义扩展 Retrofit 的功能。同时，本文提供了三个扩展机制的示例代码，可以帮助读者更加深入地了解 Retrofit 的扩展机制的使用。</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>Android 源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Retrofit 核心源码分析（二）- 网络请求和响应处理</title>
    <link href="/2023/03/08/Retrofit%20%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E5%A4%84%E7%90%86/"/>
    <url>/2023/03/08/Retrofit%20%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p><strong>在上一篇文章中，我们详细分析了 Retrofit 中的注解解析和动态代理实现，本篇文章将继续深入研究 Retrofit 的核心源码，重点分析 Retrofit 如何进行网络请求和响应处理。</strong></p><h4 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h4><p>在使用 Retrofit 发起网络请求时，我们可以通过定义一个接口并使用 Retrofit 的注解来描述这个接口中的请求，Retrofit 会自动生成一个实现该接口的代理对象。当我们调用这个代理对象的方法时，Retrofit 会根据注解的描述构建一个 Request 对象，并使用 OkHttp 将这个 Request 发送出去。</p><p>在 Retrofit 中，我们可以通过 <code>Retrofit#execute</code> 或 <code>Retrofit#enqueue</code> 方法来发送请求。这两个方法的区别在于，<code>execute</code> 方法会阻塞当前线程直到请求完成，而 <code>enqueue</code> 方法会将请求加入到 OkHttp 的请求队列中，并在请求完成时通过回调通知我们。</p><p>我们先来看一下 <code>execute</code> 方法的实现：</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vbscript"><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-keyword">execute</span>(<span class="hljs-keyword">Call</span>&lt;T&gt; <span class="hljs-keyword">call</span>) throws IOException &#123;<br>  Utils.validateServiceInterface(<span class="hljs-keyword">call</span>.<span class="hljs-built_in">request</span>().tag(), <span class="hljs-keyword">call</span>.<span class="hljs-built_in">request</span>().url().<span class="hljs-keyword">to</span><span class="hljs-built_in">String</span>());<br>  return (T) callAdapter(<span class="hljs-keyword">call</span>, <span class="hljs-keyword">call</span>.<span class="hljs-built_in">request</span>().tag()).adapt(<span class="hljs-keyword">call</span>).<span class="hljs-keyword">execute</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个方法中，首先会对接口进行校验，确保这个接口是有效的。然后我们会根据请求的 Tag 和 URL 来获取适配器<code>callAdapter</code>，并使用适配器来执行请求。</p><p>适配器的作用是将请求的参数适配成 OkHttp 能够识别的形式，并将 OkHttp 的响应适配成我们需要的形式。Retrofit 提供了一系列的适配器，包括 Call 适配器、RxJava 适配器、CompletableFuture 适配器等。</p><p>我们来看一下 <code>callAdapter</code> 方法的实现：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> CallAdapter&lt;?, ?&gt; call<span class="hljs-constructor">Adapter(Call&lt;?&gt; <span class="hljs-params">call</span>, Object <span class="hljs-params">tag</span>)</span> &#123;<br>  Type responseType = call.request<span class="hljs-literal">()</span>.<span class="hljs-keyword">method</span><span class="hljs-literal">()</span>.equals(<span class="hljs-string">&quot;HEAD&quot;</span>)<br>      ? <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Void</span>.</span></span><span class="hljs-keyword">class</span><br>      : get<span class="hljs-constructor">ParameterUpperBound(0, (ParameterizedType)</span> call.request<span class="hljs-literal">()</span>.tag<span class="hljs-literal">()</span>);<br>  return call<span class="hljs-constructor">Adapter(<span class="hljs-params">tag</span>, <span class="hljs-params">responseType</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个方法中，我们首先根据请求的方法来判断响应的类型，如果是 HEAD 方法，那么响应的类型就是 Void；否则我们会通过反射来获取请求的响应类型，并使用这个响应类型来获取适配器。</p><p>获取适配器的方法是 <code>callAdapter</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart">public &lt;R, T&gt; CallAdapter&lt;R, T&gt; callAdapter(<span class="hljs-built_in">Object</span> tag, <span class="hljs-built_in">Type</span> returnType) &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">for</span> (CallAdapter.Factory <span class="hljs-keyword">factory</span> : adapterFactories) &#123;<br>    CallAdapter&lt;?, ?&gt; adapter = <span class="hljs-keyword">factory</span>.<span class="hljs-keyword">get</span>(returnType, annotations, <span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">if</span> (adapter != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> (CallAdapter&lt;R, T&gt;) adapter;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个方法中，我们会遍历所有的适配器工厂，尝试获取适配器。在获取适配器时，我们会将请求的响应类型、注解和 Retrofit 实例作为参数传入。每个适配器工厂都会判断这些参数是否符合自己的适配条件，如果符合，就返回一个适配器实例，否则返回 null。在遍历完所有的适配器工厂之后，如果还没有获取到适配器，那么就会抛出一个异常。</p><p>获取到适配器之后，我们就可以使用适配器来执行请求了。在适配器中，我们会将请求参数转换成 OkHttp 的 Request 对象，并将 OkHttp 的 Response 对象转换成我们需要的响应类型。具体的实现可以参考 Retrofit 提供的 <code>CallAdapter</code> 接口。</p><p>对于 <code>enqueue</code> 方法，我们可以先来看一下 <code>enqueue</code> 方法的实现：</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vbscript"><span class="hljs-keyword">public</span> &lt;T&gt; void enqueue(<span class="hljs-keyword">Call</span>&lt;T&gt; <span class="hljs-keyword">call</span>, Callback&lt;T&gt; callback) &#123;<br>  Utils.validateServiceInterface(<span class="hljs-keyword">call</span>.<span class="hljs-built_in">request</span>().tag(), <span class="hljs-keyword">call</span>.<span class="hljs-built_in">request</span>().url().<span class="hljs-keyword">to</span><span class="hljs-built_in">String</span>());<br>  callAdapter(<span class="hljs-keyword">call</span>, <span class="hljs-keyword">call</span>.<span class="hljs-built_in">request</span>().tag()).adapt(<span class="hljs-keyword">call</span>).enqueue(<span class="hljs-keyword">new</span> CallbackRunnable&lt;&gt;(callback));<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个方法中，我们首先进行接口校验，然后根据请求的 Tag 和 URL 来获取适配器，并使用适配器来执行请求。不同的是，在 <code>enqueue</code> 方法中，我们将一个 Callback 对象作为参数传入适配器的 <code>enqueue</code> 方法中，以便在请求完成后回调通知我们。</p><p>在适配器中，我们可以看到 <code>enqueue</code> 方法的实现：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public void enqueue(final Callback&lt;T&gt; callback) &#123;<br>  delegate.enqueue(<span class="hljs-keyword">new</span> Callback&lt;Response&lt;T&gt;&gt;<span class="hljs-literal">()</span> &#123;<br>    @Override public void on<span class="hljs-constructor">Response(Call&lt;Response&lt;T&gt;&gt; <span class="hljs-params">call</span>, Response&lt;Response&lt;T&gt;&gt; <span class="hljs-params">response</span>)</span> &#123;<br>      Response&lt;T&gt; body;<br>      <span class="hljs-keyword">try</span> &#123;<br>        body = response.body<span class="hljs-literal">()</span>;<br>      &#125; catch (Throwable t) &#123;<br>        <span class="hljs-keyword">if</span> (response.code<span class="hljs-literal">()</span><span class="hljs-operator"> == </span><span class="hljs-number">204</span>) &#123;<br>          body = null;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          callback.on<span class="hljs-constructor">Failure(<span class="hljs-params">call</span>, <span class="hljs-params">t</span>)</span>;<br>          return;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (response.is<span class="hljs-constructor">Successful()</span>) &#123;<br>        callback.on<span class="hljs-constructor">Response(<span class="hljs-params">call</span>, Response.<span class="hljs-params">success</span>(<span class="hljs-params">body</span>, <span class="hljs-params">response</span>.<span class="hljs-params">raw</span>()</span>));<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        callback.on<span class="hljs-constructor">Failure(<span class="hljs-params">call</span>, Response.<span class="hljs-params">error</span>(<span class="hljs-params">response</span>.<span class="hljs-params">errorBody</span>()</span>, response.raw<span class="hljs-literal">()</span>));<br>      &#125;<br>    &#125;<br><br>    @Override public void on<span class="hljs-constructor">Failure(Call&lt;Response&lt;T&gt;&gt; <span class="hljs-params">call</span>, Throwable <span class="hljs-params">t</span>)</span> &#123;<br>      callback.on<span class="hljs-constructor">Failure(<span class="hljs-params">call</span>, <span class="hljs-params">t</span>)</span>;<br>    &#125;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个方法中，我们会将传入的 Callback 对象转换成一个 <code>Callback&lt;Response&lt;T&gt;&gt;</code> 对象，并使用这个对象来调用 OkHttp 的 enqueue 方法。在请求完成后，我们会将 OkHttp 的 Response 对象转换成 Retrofit 的 Response 对象，并根据响应码来判断请求的结果。如果响应码表示请求成功，那么我们就调用 Callback 对象的 <code>onResponse</code> 方法；否则就调用 Callback 对象的 <code>onFailure</code> 方法。</p><h4 id="响应处理"><a href="#响应处理" class="headerlink" title="响应处理"></a>响应处理</h4><p>在 Retrofit 中，我们可以通过定义一个接口并使用注解来描述我们期望的请求格式和响应格式。例如，我们可以通过 <code>@GET</code> 注解来描述一个 GET 请求，使用 <code>@Query</code> 注解来描述请求参数，使用 <code>@Body</code> 注解来描述请求体，使用 <code>@Headers</code> 注解来描述请求头等。</p><p>在执行请求时，Retrofit 会根据这些注解来自动生成一个对应的请求对象，并将请求对象转换成 OkHttp 的 Request 对象。在接收响应时，Retrofit 会将 OkHttp 的 Response 对象转换成一个对应的响应对象，并将响应对象中的数据转换成我们需要的数据类型。这些转换工作是通过 Retrofit 的转换器来完成的，Retrofit 中默认提供了两个转换器：<code>GsonConverterFactory</code> 和 <code>JacksonConverterFactory</code>。我们也可以自定义一个转换器来实现我们期望的数据转换。</p><p>在 Retrofit 类的构造方法中，我们可以看到 Retrofit 默认使用了 <code>Platform.get()</code> 方法来获取当前运行平台的默认转换器工厂，并将其添加到 <code>converterFactories</code> 中。然后，我们可以使用 <code>addConverterFactory</code> 方法来添加自定义的转换器工厂。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Retrofit</span>(<span class="hljs-params">Builder builder</span>)</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">if</span> (builder.converterFactories == <span class="hljs-literal">null</span>) &#123;<br>    converterFactories.<span class="hljs-keyword">add</span>(Platform.<span class="hljs-keyword">get</span>().defaultConverterFactory());<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    converterFactories.addAll(builder.converterFactories);<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Platform</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>  Converter.<span class="hljs-function">Factory <span class="hljs-title">defaultConverterFactory</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>execute</code>方法中，我们会调用适配器的 adapt 方法来执行请求，并将返回的 Call 对象转换成一个响应对象。在转换过程中，我们会根据响应类型来选择对应的转换器来进行转换。具体的转换实现可以参考 Retrofit 提供的 <code>Converter</code> 接口和 <code>Converter.Factory</code> 接口。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs scala">public &lt;<span class="hljs-type">T</span>&gt; <span class="hljs-type">T</span> execute(<span class="hljs-type">Call</span>&lt;<span class="hljs-type">T</span>&gt; call) <span class="hljs-keyword">throws</span> <span class="hljs-type">IOException</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-type">Response</span>&lt;<span class="hljs-type">T</span>&gt; response = call.execute();<br>  <span class="hljs-keyword">if</span> (response.isSuccessful()) &#123;<br>    <span class="hljs-keyword">return</span> response.body();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-type">Converter</span>&lt;<span class="hljs-type">ResponseBody</span>, <span class="hljs-type">ErrorResponse</span>&gt; converter = retrofit.responseBodyConverter(<br>        <span class="hljs-type">ErrorResponse</span>.<span class="hljs-keyword">class</span>, <span class="hljs-keyword">new</span> <span class="hljs-type">Annotation</span>[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">ApiException</span>(converter.convert(response.errorBody()));<br>  &#125;<br>&#125;<br><br><span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">&quot;unchecked&quot;</span>) <span class="hljs-comment">// Single-interface proxy creation guarded by parameter safety.</span><br>public &lt;<span class="hljs-type">T</span>&gt; <span class="hljs-type">T</span> adapt(<span class="hljs-type">Call</span>&lt;<span class="hljs-type">T</span>&gt; call) &#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">T</span>) <span class="hljs-keyword">new</span> <span class="hljs-type">OkHttpCall</span>&lt;&gt;(requestFactory, callFactory, converter, call);<br>&#125;<br><br>public &lt;<span class="hljs-type">T</span>&gt; <span class="hljs-type">Converter</span>&lt;<span class="hljs-type">ResponseBody</span>, <span class="hljs-type">T</span>&gt; responseBodyConverter(<span class="hljs-type">Type</span> <span class="hljs-class"><span class="hljs-keyword">type</span>, <span class="hljs-title">Annotation</span>[] <span class="hljs-title">annotations</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> nextResponseBodyConverter(<span class="hljs-literal">null</span>, <span class="hljs-class"><span class="hljs-keyword">type</span>, <span class="hljs-title">annotations</span>)</span>;<br>&#125;<br><br>public &lt;<span class="hljs-type">T</span>&gt; <span class="hljs-type">Converter</span>&lt;<span class="hljs-type">ResponseBody</span>, <span class="hljs-type">T</span>&gt; nextResponseBodyConverter(<br>    <span class="hljs-meta">@Nullable</span> <span class="hljs-type">Converter</span>.<span class="hljs-type">Factory</span> skipPast, <span class="hljs-type">Type</span> <span class="hljs-class"><span class="hljs-keyword">type</span>, <span class="hljs-title">Annotation</span>[] <span class="hljs-title">annotations</span>) </span>&#123;<br>  <span class="hljs-type">Objects</span>.requireNonNull(<span class="hljs-class"><span class="hljs-keyword">type</span>, &quot;<span class="hljs-title">type</span> <span class="hljs-title">==</span> <span class="hljs-title">null</span>&quot;)</span>;<br>  <span class="hljs-type">Objects</span>.requireNonNull(annotations, <span class="hljs-string">&quot;annotations == null&quot;</span>);<br><br>  int start = converterFactories.indexOf(skipPast) + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (int i = start, count = converterFactories.size(); i &lt; count; i++) &#123;<br>    <span class="hljs-type">Converter</span>&lt;<span class="hljs-type">ResponseBody</span>, ?&gt; converter =<br>        converterFactories.get(i).responseBodyConverter(<span class="hljs-class"><span class="hljs-keyword">type</span>, <span class="hljs-title">annotations</span>, <span class="hljs-title">this</span>)</span>;<br>    <span class="hljs-keyword">if</span> (converter != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> (<span class="hljs-type">Converter</span>&lt;<span class="hljs-type">ResponseBody</span>, <span class="hljs-type">T</span>&gt;) converter;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">IllegalArgumentException</span>(<br>      <span class="hljs-string">&quot;Could not locate ResponseBody converter for &quot;</span> + <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">+</span> &quot; <span class="hljs-keyword">with</span> <span class="hljs-title">annotations</span> &quot; <span class="hljs-title">+</span> <span class="hljs-title">Arrays</span>.<span class="hljs-title">toString</span>(<span class="hljs-params">annotations</span>))</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上是 Retrofit 中处理响应的核心代码。当我们执行一个请求时，Retrofit 会先将请求转换成 OkHttp 的 Request 对象并发送出去，然后等待响应返回。当响应返回时，Retrofit 会将响应转换成一个响应对象，并将响应对象中的数据转换成我们期望的数据类型。这个过程中，我们可以使用 Retrofit 提供的转换器来自定义数据的转换规则。</p><p>下面是一个示例，演示了如何使用 Retrofit 来发送一个 GET 请求并将响应中的 JSON 数据转换成一个 Java 对象：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> interface ApiService &#123;<br>  @<span class="hljs-keyword">GET</span>(&quot;users/&#123;user&#125;/repos&quot;)<br>  <span class="hljs-keyword">Call</span>&lt;List&lt;Repo&gt;&gt; listRepos(@Path(&quot;user&quot;) String <span class="hljs-keyword">user</span>);<br>&#125;<br><br>Retrofit retrofit = <span class="hljs-built_in">new</span> Retrofit.Builder()<br>    .baseUrl(&quot;https://api.github.com/&quot;)<br>    .addConverterFactory(GsonConverterFactory.<span class="hljs-keyword">create</span>())<br>    .build();<br><br>ApiService apiService = retrofit.<span class="hljs-keyword">create</span>(ApiService.<span class="hljs-keyword">class</span>);<br><span class="hljs-keyword">Call</span>&lt;List&lt;Repo&gt;&gt; <span class="hljs-keyword">call</span> = apiService.listRepos(&quot;smallmarker&quot;);<br>List&lt;Repo&gt; repos = <span class="hljs-keyword">call</span>.<span class="hljs-keyword">execute</span>().body();<br></code></pre></td></tr></table></figure><p>在上面的示例中，我们首先使用 Retrofit 构建器创建一个 Retrofit 实例，并指定了请求的基础 URL 和转换器工厂。然后，我们通过调用 <code>create</code> 方法来创建一个 <code>ApiService</code> 的代理对象。最后，我们调用 <code>listRepos</code> 方法来发送一个 GET 请求。</p><p>在上面的示例中，我们使用了 Retrofit 的 <code>GsonConverterFactory</code> 来将响应体中的 JSON 数据转换成 Java 对象。具体实现可以查看 Retrofit 提供的 <code>GsonConverterFactory</code> 类。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> final <span class="hljs-keyword">class</span> <span class="hljs-title class_">GsonConverterFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Converter.Factory</span> &#123;<br>  <span class="hljs-keyword">private</span> final <span class="hljs-title class_">Gson</span> gson;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-title class_">GsonConverterFactory</span>(<span class="hljs-title class_">Gson</span> gson) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">gson</span> = gson;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">GsonConverterFactory</span> <span class="hljs-title function_">create</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">create</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Gson</span>());<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">GsonConverterFactory</span> <span class="hljs-title function_">create</span>(<span class="hljs-params">Gson gson</span>) &#123;<br>    <span class="hljs-keyword">if</span> (gson == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;gson == null&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GsonConverterFactory</span>(gson);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-meta">@Nullable</span> <span class="hljs-title class_">Converter</span>&lt;<span class="hljs-title class_">ResponseBody</span>, ?&gt; <span class="hljs-title function_">responseBodyConverter</span>(<span class="hljs-params">Type <span class="hljs-keyword">type</span>, Annotation[] annotations, Retrofit retrofit</span>) &#123;<br>    <span class="hljs-title class_">TypeAdapter</span>&lt;?&gt; adapter = gson.<span class="hljs-title function_">getAdapter</span>(<span class="hljs-title class_">TypeToken</span>.<span class="hljs-title function_">get</span>(<span class="hljs-keyword">type</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GsonResponseBodyConverter</span>&lt;&gt;(gson, adapter);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-meta">@Nullable</span> <span class="hljs-title class_">Converter</span>&lt;?, <span class="hljs-title class_">RequestBody</span>&gt; <span class="hljs-title function_">requestBodyConverter</span>(<span class="hljs-params">Type <span class="hljs-keyword">type</span>, Annotation[] parameterAnnotations,</span><br><span class="hljs-params">                                                                  Annotation[] methodAnnotations, Retrofit retrofit</span>) &#123;<br>    <span class="hljs-title class_">TypeAdapter</span>&lt;?&gt; adapter = gson.<span class="hljs-title function_">getAdapter</span>(<span class="hljs-title class_">TypeToken</span>.<span class="hljs-title function_">get</span>(<span class="hljs-keyword">type</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GsonRequestBodyConverter</span>&lt;&gt;(gson, adapter);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，<code>GsonConverterFactory</code> 继承了 Retrofit 的 <code>Converter.Factory</code> 类，并重写了其中的 <code>responseBodyConverter</code> 方法和 <code>requestBodyConverter</code> 方法。在 <code>responseBodyConverter</code> 方法中，我们将响应体中的 JSON 数据转换成 Java 对象，而在 <code>requestBodyConverter</code> 方法中，我们将 Java 对象转换成请求体中的 JSON 数据。</p><p>除了 <code>GsonConverterFactory</code> 以外，Retrofit 还提供了其他的转换器，如 <code>JacksonConverterFactory、MoshiConverterFactory</code> 等，我们可以根据需要选择适合自己的转换器。</p><p>总的来说，Retrofit 中网络请求和响应处理的核心代码非常简洁明了。我们只需要通过定义接口来描述请求和响应，然后使用 Retrofit 的动态代理机制来将接口转换成一个实际的实现类，并通过 Retrofit 的配置来指定请求和响应的转换器即可。这种方式大大简化了网络请求的流程，使得我们可以更加专注于业务逻辑的处理。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android 源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Retrofit 核心源码分析（一）- 注解解析和动态代理</title>
    <link href="/2023/03/07/Retrofit%20%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89-%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <url>/2023/03/07/Retrofit%20%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89-%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p><strong>Retrofit是目前Android平台上比较流行的网络请求框架之一，它提供了一种简洁、灵活的方式来处理HTTP请求和响应。Retrofit的设计目的是使网络请求的代码更加容易编写和阅读，同时还提供了许多有用的特性，如注解解析、动态代理等。在本文中，我们将对Retrofit的注解解析和动态代理进行详细的分析。</strong></p><h4 id="注解解析"><a href="#注解解析" class="headerlink" title="注解解析"></a>注解解析</h4><p>在使用Retrofit时，我们通常会定义一个接口，该接口用于描述我们要请求的API接口。在这个接口中，我们可以使用注解来描述API的各个方面，如HTTP方法、请求URL、请求参数等。Retrofit会根据这些注解来生成相应的网络请求代码。下面是一个示例：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">interface</span> <span class="hljs-selector-tag">GitHubService</span> &#123;<br>    <span class="hljs-variable">@GET</span>(<span class="hljs-string">&quot;users/&#123;user&#125;/repos&quot;</span>)<br>    fun listRepos(<span class="hljs-variable">@Path</span>(<span class="hljs-string">&quot;user&quot;</span>) <span class="hljs-attribute">user</span>: String): Call&lt;List&lt;Repo&gt;&gt;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个示例中，@GET注解表示这是一个HTTP GET请求，”users/{user}/repos”表示请求的URL，@Path(“user”)表示请求URL中的参数。Retrofit会解析这些注解，并生成相应的网络请求代码。</p><p>Retrofit中的注解解析是通过Retrofit.Builder中的retrofit2.Retrofit#create方法实现的。这个方法会返回一个代理对象，该代理对象会在调用接口方法时解析注解并生成相应的网络请求。</p><p>下面是retrofit2.Retrofit#create方法的核心代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Utils</span>.</span></span>validate<span class="hljs-constructor">ServiceInterface(<span class="hljs-params">service</span>)</span>;<br>    <span class="hljs-keyword">if</span> (validateEagerly) &#123;<br>        eagerly<span class="hljs-constructor">ValidateMethods(<span class="hljs-params">service</span>)</span>;<br>    &#125;<br>    return (T) <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Proxy</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">ProxyInstance(<span class="hljs-params">service</span>.<span class="hljs-params">getClassLoader</span>()</span>, <span class="hljs-keyword">new</span> Class&lt;?&gt;<span class="hljs-literal">[]</span> &#123; service &#125;,<br>            <span class="hljs-keyword">new</span> <span class="hljs-constructor">InvocationHandler()</span> &#123;<br>                <span class="hljs-keyword">private</span> final Platform platform = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Platform</span>.</span></span>get<span class="hljs-literal">()</span>;<br><br>                @Override<br>                public Object invoke(Object proxy, Method <span class="hljs-keyword">method</span>, Object<span class="hljs-literal">[]</span> args)<br>                        throws Throwable &#123;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">method</span>.get<span class="hljs-constructor">DeclaringClass()</span><span class="hljs-operator"> == </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span><span class="hljs-keyword">class</span>) &#123;<br>                        return <span class="hljs-keyword">method</span>.invoke(this, args);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (platform.is<span class="hljs-constructor">DefaultMethod(<span class="hljs-params">method</span>)</span>) &#123;<br>                        return platform.invoke<span class="hljs-constructor">DefaultMethod(<span class="hljs-params">method</span>, <span class="hljs-params">service</span>, <span class="hljs-params">proxy</span>, <span class="hljs-params">args</span>)</span>;<br>                    &#125;<br>                    ServiceMethod&lt;Object, Object&gt; serviceMethod =<br>                            (ServiceMethod&lt;Object, Object&gt;) load<span class="hljs-constructor">ServiceMethod(<span class="hljs-params">method</span>)</span>;<br>                    OkHttpCall&lt;Object&gt; okHttpCall = <span class="hljs-keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);<br>                    return serviceMethod.callAdapter.adapt(okHttpCall);<br>                &#125;<br>            &#125;);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>该方法首先会验证接口是否满足要求，然后会返回一个代理对象。这个代理对象实现了接口中的所有方法，并在调用方法时解析注解并生成相应的网络请求。</p><p>我们可以看到，代理对象的实现是通过java.lang.reflect.Proxy类实现的。Proxy.newProxyInstance方法会返回一个代理对象，该代理对象实现了指定接口中的所有方法。当我们调用代理对象的方法时，代理对象会调用InvocationHandler.invoke方法，该方法中实现了注解解析和网络请求的生成。</p><p>在InvocationHandler.invoke方法中，首先会判断是否调用了Object类的方法，如果是，则直接返回该方法的执行结果。如果不是，则进一步判断是否调用了接口的默认方法，如果是，则使用Platform类调用默认方法。否则，就调用loadServiceMethod方法来解析注解并生成网络请求。</p><p>loadServiceMethod方法会首先从缓存中获取ServiceMethod对象，如果缓存中没有，则创建一个新的ServiceMethod对象。ServiceMethod对象包含了网络请求的相关信息，如HTTP方法、请求URL、请求参数等。ServiceMethod对象的创建是通过ServiceMethod.Builder类实现的，该类会解析接口方法上的注解并生成相应的网络请求。</p><p>下面是ServiceMethod.Builder类的核心代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> ServiceMethod <span class="hljs-title">build</span>()</span> &#123;<br>    callAdapter = createCallAdapter();<br>    responseType = callAdapter.responseType();<br>    <span class="hljs-keyword">if</span> (responseType == Response.<span class="hljs-keyword">class</span> || responseType == okhttp3.Response.<span class="hljs-keyword">class</span>) &#123;<br>        <span class="hljs-keyword">throw</span> methodError(<span class="hljs-string">&quot;&#x27;&quot;</span><br>                + Utils.getRawType(responseType).getName()<br>                + <span class="hljs-string">&quot;&#x27; is not a valid response body type. Did you mean ResponseBody?&quot;</span>);<br>    &#125;<br>    responseConverter = createResponseConverter();<br>    RequestFactory requestFactory = createRequestFactory();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ServiceMethod&lt;&gt;(requestFactory, callAdapter, responseConverter);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在ServiceMethod.Builder类中，首先会创建一个CallAdapter对象，该对象用于处理网络请求的结果。然后会检查responseType是否是Response或okhttp3.Response类型，如果是，则抛出异常。接下来，会创建一个ResponseConverter对象，该对象用于将网络请求的结果转换成Java对象。最后，会创建一个RequestFactory对象，该对象用于创建okhttp3.Request对象。</p><p>ServiceMethod对象包含了网络请求的相关信息，包括RequestFactory对象、CallAdapter对象和ResponseConverter对象。OkHttpCall对象则负责执行网络请求，并将结果传递给CallAdapter对象进行处理。CallAdapter对象最终将结果转换成Java对象并返回给调用者。</p><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>在前面的代码中，我们已经看到了动态代理的使用。在Retrofit中，我们使用动态代理来实现注解解析和网络请求的生成。动态代理是一种机制，通过它我们可以在运行时创建一个代理对象，该代理对象会代替原始对象来执行方法调用。</p><p>在Retrofit中，我们使用动态代理来创建一个实现接口的代理对象。当我们调用代理对象的方法时，代理对象会调用InvocationHandler.invoke方法，该方法中实现了注解解析和网络请求的生成。因此，我们可以将网络请求的代码封装在接口中，使得我们的代码更加简洁和易于阅读。</p><p>下面是一个使用动态代理的简单示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> java.lang.reflect.*<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HelloWorld</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldImpl</span> : <span class="hljs-type">HelloWorld &#123;</span></span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;Hello, world!&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> proxy = Proxy.newProxyInstance(<br>        DynamicProxyExample::<span class="hljs-keyword">class</span>.java.classLoader,<br>        arrayOf(HelloWorld::<span class="hljs-keyword">class</span>.java),<br>        <span class="hljs-keyword">object</span> : InvocationHandler &#123;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> target: HelloWorld = HelloWorldImpl()<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">(proxy: <span class="hljs-type">Any</span>?, method: <span class="hljs-type">Method</span>?, args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">out</span> <span class="hljs-type">Any</span>&gt;?)</span></span>: Any? &#123;<br>                println(<span class="hljs-string">&quot;Before method execution...&quot;</span>)<br>                <span class="hljs-keyword">val</span> result = method?.invoke(target, *(args ?: emptyArray()))<br>                println(<span class="hljs-string">&quot;After method execution...&quot;</span>)<br>                <span class="hljs-keyword">return</span> result<br>            &#125;<br>        &#125;<br>    ) <span class="hljs-keyword">as</span> HelloWorld<br>    proxy.sayHello()<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个<code>HelloWorld</code>接口和一个<code>HelloWorldImpl</code>实现类。然后，我们使用动态代理创建了一个代理对象，该代理对象实现了<code>HelloWorld</code>接口。在<code>InvocationHandler</code>的<code>invoke</code>方法中，我们首先输出一行日志，然后调用<code>HelloWorldImpl</code>对象的<code>sayHello</code>方法，最后再输出一行日志。当我们调用代理对象的<code>sayHello</code>方法时，代理对象会调用<code>InvocationHandler.invoke</code>方法，从而实现了在方法执行前后输出日志的功能。动态代理是一种非常强大的机制，可以用于实现很多功能，如性能分析、日志记录、事务管理等。在Retrofit中，我们使用动态代理来实现注解解析和网络请求的生成，从而使得我们的代码更加简洁和易于阅读。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android 源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 流式布局TagFlowLayout</title>
    <link href="/2022/07/25/Android-%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80TagFlowLayout/"/>
    <url>/2022/07/25/Android-%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80TagFlowLayout/</url>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>这是一个Android流式布局，根据鸿翔大神之前写的<a href="https://github.com/hongyangAndroid/FlowLayout">FlowLayout</a>设计思路结合<code>Material</code>库中的<code>ChipGroup</code>设计架构衍生而来，全新的流式布局<a href="https://github.com/smallmarker/TagFlowLayout">TagFlowLayout</a>组件</strong></p><h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><p><img src="tagflowlayout_demo.gif" alt="tagflowlayout_demo"></p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="setter"><a href="#setter" class="headerlink" title="setter"></a>setter</h4><table><thead><tr><th align="center">方法名称</th><th align="center">作用</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center"><code>setTagSpacingHorizontal(@Dimension tagSpacingHorizontal: Int)</code></td><td align="center">Tag间的水平间距</td><td align="center"><code>setTagSpacingHorizontal(24)</code></td></tr><tr><td align="center"><code>setTagSpacingVertical(@Dimension tagSpacingVertical: Int)</code></td><td align="center">Tag间的垂直间距</td><td align="center"><code>setTagSpacingVertical(24)</code></td></tr><tr><td align="center"><code>setSingleLine(singleLine: Boolean)</code></td><td align="center">是否开启单行模式（默认false）</td><td align="center"><code>setSingleLine(true)</code></td></tr><tr><td align="center"><code>setSingleSelection(singleSelection: Boolean)</code></td><td align="center">是否开启单选模式（默认false）</td><td align="center"><code>setSingleSelection(true)</code></td></tr><tr><td align="center"><code>setSelectionRequired(selectionRequired: Boolean)</code></td><td align="center">是否为必选项（默认false</td><td align="center"><code>setSelectionRequired(true)</code></td></tr><tr><td align="center"><code>setSelectMax(selectMax: Int)</code></td><td align="center">最大选择数量（&lt;=0为无效值</td><td align="center"><code>setSelectMax(10)</code></td></tr><tr><td align="center"><code>setOnTagClickListener(tagClickListener: TagClickListener)</code></td><td align="center">设置Tag点击事件</td><td align="center"><code>setOnTagClickListener &#123; view, position, parent -&gt; &#125;</code></td></tr><tr><td align="center"><code>setCheckedChangedListener(checkedChangedListener: CheckedChangedListener)</code></td><td align="center">设置Tag状态变更监听事件</td><td align="center"><code>setCheckedChangedListener &#123; group, checkedIds -&gt; &#125;</code></td></tr></tbody></table><h4 id="getter"><a href="#getter" class="headerlink" title="getter"></a>getter</h4><table><thead><tr><th align="center">方法名称</th><th align="center">作用</th><th align="center">返回类型</th></tr></thead><tbody><tr><td align="center"><code>isSelectMax()</code></td><td align="center">是否达到最大的选择数量</td><td align="center"><code>Boolean</code></td></tr><tr><td align="center"><code>clearCheck()</code></td><td align="center">清除所有选中数据</td><td align="center"><code>void</code></td></tr><tr><td align="center"><code>getCheckedTagOrder()</code></td><td align="center">获取选中单选下标</td><td align="center"><code>Int</code></td></tr><tr><td align="center"><code>getCheckedTagOrders()</code></td><td align="center">获取选中集合下标组</td><td align="center"><code>List&lt;Int&gt;</code></td></tr></tbody></table><h4 id="Attributes属性"><a href="#Attributes属性" class="headerlink" title="Attributes属性"></a>Attributes属性</h4><table><thead><tr><th align="center">属性名称</th><th align="center">作用</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center"><code>app:tagSpacing</code></td><td align="center">Tag间的间距</td><td align="center"><code>app:tagSpacing=&quot;24dp&quot;</code></td></tr><tr><td align="center"><code>app:tagSpacingHorizontal</code></td><td align="center">Tag间的水平间距</td><td align="center"><code>app:tagSpacingHorizontal=&quot;24dp&quot;</code></td></tr><tr><td align="center"><code>app:tagSpacingVertical</code></td><td align="center">Tag间的垂直间距</td><td align="center"><code>app:tagSpacingVertical=&quot;24dp&quot;</code></td></tr><tr><td align="center"><code>app:singleLine</code></td><td align="center">是否开启单行模式（默认false）</td><td align="center"><code>app:singleLine=&quot;true&quot;</code></td></tr><tr><td align="center"><code>app:singleSelection</code></td><td align="center">是否开启单选模式（默认false）</td><td align="center"><code>app:是否开启单选模式=&quot;true&quot;</code></td></tr><tr><td align="center"><code>app:selectionRequired</code></td><td align="center">是否为必选项（默认false）</td><td align="center"><code>app:selectionRequired=&quot;true&quot;</code></td></tr><tr><td align="center"><code>app:selectMax</code></td><td align="center">最大选择数量（&lt;=0为无效值）</td><td align="center"><code>app:selectMax=&quot;10&quot;</code></td></tr></tbody></table><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">dependencies &#123;<br>    <span class="hljs-keyword">implementation</span> <span class="hljs-string">&#x27;io.github.smallmarker:tagflowlayout:1.0&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;com.smallmarker.tagflowlayout.TagFlowLayout<br>            android:<span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;@+id/tag_flow_layout&quot;</span><br>            android:<span class="hljs-attribute">layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span><br>            android:<span class="hljs-attribute">layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span><br>            app:<span class="hljs-attribute">tagSpacing</span>=<span class="hljs-string">&quot;16dp&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><h3 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h3><h4 id="方法属性"><a href="#方法属性" class="headerlink" title="方法属性"></a>方法属性</h4><ul><li>创建Adapter：<code>TagFlowAdapter.create(dataList)</code></li><li>设置Tag：<code>setView(parent: TagFlowLayout, position: Int, t: T)</code></li><li>设置Tag状态：<code>setChecked(position: Int, t: T)</code></li><li>监听状态变化：<code>setCheckedChanged(isChecked: Boolean, position: Int, view: View)</code></li><li>刷新适配器：<code>notifyDataSetChange()</code></li></ul><h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h4><ul><li><strong>设置数据</strong></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 设置Adapter</span><br>binding<span class="hljs-selector-class">.tagFlowLayout</span><span class="hljs-selector-class">.adapter</span> = TagFlowAdapter<span class="hljs-selector-class">.create</span>(dataList) &#123;<br>    setView &#123; parent, <span class="hljs-attribute">position</span>, t -&gt;<br>        <span class="hljs-built_in">TextView</span>(parent.context)<span class="hljs-selector-class">.apply</span> &#123;<br>            text = t<br>            <span class="hljs-built_in">setBackgroundResource</span>(R<span class="hljs-selector-class">.drawable</span>.bg_tag_selector)<br>            <span class="hljs-built_in">setPadding</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>选中状态</strong></li></ul><p>支持通过<code>state=checked</code>来控制选中和取消</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">selector</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">android:state_checked</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">shape</span> <span class="hljs-attr">android:shape</span>=<span class="hljs-string">&quot;rectangle&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">corners</span> <span class="hljs-attr">android:radius</span>=<span class="hljs-string">&quot;6dp&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">stroke</span> <span class="hljs-attr">android:width</span>=<span class="hljs-string">&quot;1.2dp&quot;</span> <span class="hljs-attr">android:color</span>=<span class="hljs-string">&quot;#374D9D&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">shape</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">shape</span> <span class="hljs-attr">android:shape</span>=<span class="hljs-string">&quot;rectangle&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">corners</span> <span class="hljs-attr">android:radius</span>=<span class="hljs-string">&quot;6dp&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">stroke</span> <span class="hljs-attr">android:width</span>=<span class="hljs-string">&quot;1.2dp&quot;</span> <span class="hljs-attr">android:color</span>=<span class="hljs-string">&quot;#C4C7D1&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">shape</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">selector</span>&gt;</span><br></code></pre></td></tr></table></figure><p>也可以自己在<code>Adapter</code> 的<code>setCheckedChanged</code>处理显示</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">setCheckedChanged &#123; isChecked, <span class="hljs-attribute">position</span>, view -&gt;<br>                Log<span class="hljs-selector-class">.d</span>(<span class="hljs-string">&quot;TAG&quot;</span>, <span class="hljs-string">&quot;当前TAG状态：$&#123;isChecked&#125;, $&#123;position&#125;&quot;</span>)<br>                view<span class="hljs-selector-class">.setBackgroundColor</span>(<span class="hljs-keyword">if</span> (isChecked) &#123;<br>                    Color<span class="hljs-selector-class">.RED</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    Color<span class="hljs-selector-class">.GRAY</span><br>                &#125;)<br>            &#125;<br></code></pre></td></tr></table></figure><ul><li><strong>事件</strong></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 点击事件</span><br>binding<span class="hljs-selector-class">.tagFlowLayout</span><span class="hljs-selector-class">.setOnTagClickListener</span> &#123; view, <span class="hljs-attribute">position</span>, parent -&gt;<br>    Log<span class="hljs-selector-class">.d</span>(<span class="hljs-string">&quot;TAG&quot;</span>, <span class="hljs-string">&quot;当前选中TAG： $&#123;position&#125;&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 状态监听</span><br>binding<span class="hljs-selector-class">.tagFlowLayout</span><span class="hljs-selector-class">.setCheckedChangedListener</span> &#123; group, checkedIds -&gt;<br>    binding<span class="hljs-selector-class">.tvTip</span><span class="hljs-selector-class">.text</span> = <span class="hljs-string">&quot;当前选中TAG序号：$&#123;checkedIds&#125;&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>偶然发现<code>material</code>库中<code>chip</code>组件，其通过<code>ChipGroup</code>实现流式布局的设计，加上很早之前有用过鸿神的<code>FlowLayout</code>库，所以就在此基础上写了一个新的流式布局组件，该组件在类的命名上还是沿用了鸿神之前的<code>FlowLayout</code>，为了不依赖<code>material</code>库的较高版本的限制，故将需要用到的类抽取使用，做兼容处理</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>Android 组件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android AGP升级后导致APK体积增大</title>
    <link href="/2022/06/10/Android-AGP%E5%8D%87%E7%BA%A7%E5%90%8E%E5%AF%BC%E8%87%B4APK%E4%BD%93%E7%A7%AF%E5%A2%9E%E5%A4%A7/"/>
    <url>/2022/06/10/Android-AGP%E5%8D%87%E7%BA%A7%E5%90%8E%E5%AF%BC%E8%87%B4APK%E4%BD%93%E7%A7%AF%E5%A2%9E%E5%A4%A7/</url>
    
    <content type="html"><![CDATA[<p><strong>项目AGP升级至7.0+后发现打出来release包的体积比之前增加近一倍，经过查询官方文档得知在AGP3.6.0时的行为变更上：默认情况下，原生库以未压缩的形式打包。</strong></p><p>在构建应用时，插件现在默认会将 <code>extractNativeLibs</code> 设置为<code> &quot;false&quot;</code>也就是说，您的原生库将保持页面对齐状态并以未压缩的形式打包。虽然这样会增加上传大小，但您的用户会从以下优势中受益：</p><ul><li>减小应用安装大小，因为平台可以直接从已安装的 APK 访问原生库，而无需创建库的副本。</li><li>减小下载文件大小，因为在 APK 或 <code>Android App Bundle</code> 中添加未压缩的原生库通常可提高 Play 商店的压缩率。</li></ul><p>如果您希望 <code>Android Gradle</code> 插件改为打包压缩后的原生库，请在应用的清单中添加以下代码：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-built_in">application</span><br>    android:extractNativeLibs=<span class="hljs-string">&quot;true&quot;</span><br>    ... &gt;<br>&lt;/<span class="hljs-built_in">application</span>&gt;<br></code></pre></td></tr></table></figure><p><strong>但是从 AGP 4.2.0 开始，<code>extractNativeLibs</code> 清单属性已被 DSL 选项 <code>useLegacyPackaging</code> 取代。 您应该使用应用的 <code>build.gradle</code> 文件中的 <code>useLegacyPackaging</code>（而非清单文件中的 <code>extractNativeLibs</code>）来配置原生库压缩行为：</strong></p><h5 id="使用-DSL-打包压缩后的原生库"><a href="#使用-DSL-打包压缩后的原生库" class="headerlink" title="使用 DSL 打包压缩后的原生库"></a>使用 DSL 打包压缩后的原生库</h5><p>官方建议以未压缩的形式打包原生库，因为这会减小应用安装大小，缩减应用下载大小，并缩短用户的应用加载时间。不过，如果您希望 <code>Android Gradle</code> 插件在构建应用时打包压缩后的原生库，请在应用的 <code>build.gradle</code> 文件中将 <code>useLegacyPackaging</code>设置为 <code>true</code>：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">android</span> &#123;<br>    <span class="hljs-keyword">packagingOptions</span> &#123;<br>        <span class="hljs-keyword">jniLibs</span> &#123;<br>            useLegacyPackaging <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：<code>useLegacyPackaging</code> 标记会替换 <code>extractNativeLibs</code> 清单属性。默认情况下，原生库以未压缩的形式打包。</strong></p><p>官方文档参考：</p><p><a href="https://developer.android.com/studio/releases/gradle-plugin?buildsystem=ndk-build#extractNativeLibs">https://developer.android.com/studio/releases/gradle-plugin?buildsystem=ndk-build#extractNativeLibs</a></p><p><a href="https://developer.android.com/studio/releases/gradle-plugin?buildsystem=ndk-build#compress-native-libs-dsl">https://developer.android.com/studio/releases/gradle-plugin?buildsystem=ndk-build#compress-native-libs-dsl</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Android 奇遇记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
