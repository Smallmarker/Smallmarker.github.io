<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Retrofit 核心源码分析（一）- 注解解析和动态代理</title>
    <link href="/2023/03/07/Retrofit%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89-%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <url>/2023/03/07/Retrofit%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89-%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p><strong>Retrofit是目前Android平台上比较流行的网络请求框架之一，它提供了一种简洁、灵活的方式来处理HTTP请求和响应。Retrofit的设计目的是使网络请求的代码更加容易编写和阅读，同时还提供了许多有用的特性，如注解解析、动态代理等。在本文中，我们将对Retrofit的注解解析和动态代理进行详细的分析。</strong></p><h4 id="注解解析"><a href="#注解解析" class="headerlink" title="注解解析"></a>注解解析</h4><p>在使用Retrofit时，我们通常会定义一个接口，该接口用于描述我们要请求的API接口。在这个接口中，我们可以使用注解来描述API的各个方面，如HTTP方法、请求URL、请求参数等。Retrofit会根据这些注解来生成相应的网络请求代码。下面是一个示例：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">interface</span> <span class="hljs-selector-tag">GitHubService</span> &#123;<br>    <span class="hljs-variable">@GET</span>(<span class="hljs-string">&quot;users/&#123;user&#125;/repos&quot;</span>)<br>    fun listRepos(<span class="hljs-variable">@Path</span>(<span class="hljs-string">&quot;user&quot;</span>) <span class="hljs-attribute">user</span>: String): Call&lt;List&lt;Repo&gt;&gt;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个示例中，@GET注解表示这是一个HTTP GET请求，”users/{user}/repos”表示请求的URL，@Path(“user”)表示请求URL中的参数。Retrofit会解析这些注解，并生成相应的网络请求代码。</p><p>Retrofit中的注解解析是通过Retrofit.Builder中的retrofit2.Retrofit#create方法实现的。这个方法会返回一个代理对象，该代理对象会在调用接口方法时解析注解并生成相应的网络请求。</p><p>下面是retrofit2.Retrofit#create方法的核心代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Utils</span>.</span></span>validate<span class="hljs-constructor">ServiceInterface(<span class="hljs-params">service</span>)</span>;<br>    <span class="hljs-keyword">if</span> (validateEagerly) &#123;<br>        eagerly<span class="hljs-constructor">ValidateMethods(<span class="hljs-params">service</span>)</span>;<br>    &#125;<br>    return (T) <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Proxy</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">ProxyInstance(<span class="hljs-params">service</span>.<span class="hljs-params">getClassLoader</span>()</span>, <span class="hljs-keyword">new</span> Class&lt;?&gt;<span class="hljs-literal">[]</span> &#123; service &#125;,<br>            <span class="hljs-keyword">new</span> <span class="hljs-constructor">InvocationHandler()</span> &#123;<br>                <span class="hljs-keyword">private</span> final Platform platform = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Platform</span>.</span></span>get<span class="hljs-literal">()</span>;<br><br>                @Override<br>                public Object invoke(Object proxy, Method <span class="hljs-keyword">method</span>, Object<span class="hljs-literal">[]</span> args)<br>                        throws Throwable &#123;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">method</span>.get<span class="hljs-constructor">DeclaringClass()</span><span class="hljs-operator"> == </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span><span class="hljs-keyword">class</span>) &#123;<br>                        return <span class="hljs-keyword">method</span>.invoke(this, args);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (platform.is<span class="hljs-constructor">DefaultMethod(<span class="hljs-params">method</span>)</span>) &#123;<br>                        return platform.invoke<span class="hljs-constructor">DefaultMethod(<span class="hljs-params">method</span>, <span class="hljs-params">service</span>, <span class="hljs-params">proxy</span>, <span class="hljs-params">args</span>)</span>;<br>                    &#125;<br>                    ServiceMethod&lt;Object, Object&gt; serviceMethod =<br>                            (ServiceMethod&lt;Object, Object&gt;) load<span class="hljs-constructor">ServiceMethod(<span class="hljs-params">method</span>)</span>;<br>                    OkHttpCall&lt;Object&gt; okHttpCall = <span class="hljs-keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);<br>                    return serviceMethod.callAdapter.adapt(okHttpCall);<br>                &#125;<br>            &#125;);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>该方法首先会验证接口是否满足要求，然后会返回一个代理对象。这个代理对象实现了接口中的所有方法，并在调用方法时解析注解并生成相应的网络请求。</p><p>我们可以看到，代理对象的实现是通过java.lang.reflect.Proxy类实现的。Proxy.newProxyInstance方法会返回一个代理对象，该代理对象实现了指定接口中的所有方法。当我们调用代理对象的方法时，代理对象会调用InvocationHandler.invoke方法，该方法中实现了注解解析和网络请求的生成。</p><p>在InvocationHandler.invoke方法中，首先会判断是否调用了Object类的方法，如果是，则直接返回该方法的执行结果。如果不是，则进一步判断是否调用了接口的默认方法，如果是，则使用Platform类调用默认方法。否则，就调用loadServiceMethod方法来解析注解并生成网络请求。</p><p>loadServiceMethod方法会首先从缓存中获取ServiceMethod对象，如果缓存中没有，则创建一个新的ServiceMethod对象。ServiceMethod对象包含了网络请求的相关信息，如HTTP方法、请求URL、请求参数等。ServiceMethod对象的创建是通过ServiceMethod.Builder类实现的，该类会解析接口方法上的注解并生成相应的网络请求。</p><p>下面是ServiceMethod.Builder类的核心代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> ServiceMethod <span class="hljs-title">build</span>()</span> &#123;<br>    callAdapter = createCallAdapter();<br>    responseType = callAdapter.responseType();<br>    <span class="hljs-keyword">if</span> (responseType == Response.<span class="hljs-keyword">class</span> || responseType == okhttp3.Response.<span class="hljs-keyword">class</span>) &#123;<br>        <span class="hljs-keyword">throw</span> methodError(<span class="hljs-string">&quot;&#x27;&quot;</span><br>                + Utils.getRawType(responseType).getName()<br>                + <span class="hljs-string">&quot;&#x27; is not a valid response body type. Did you mean ResponseBody?&quot;</span>);<br>    &#125;<br>    responseConverter = createResponseConverter();<br>    RequestFactory requestFactory = createRequestFactory();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ServiceMethod&lt;&gt;(requestFactory, callAdapter, responseConverter);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在ServiceMethod.Builder类中，首先会创建一个CallAdapter对象，该对象用于处理网络请求的结果。然后会检查responseType是否是Response或okhttp3.Response类型，如果是，则抛出异常。接下来，会创建一个ResponseConverter对象，该对象用于将网络请求的结果转换成Java对象。最后，会创建一个RequestFactory对象，该对象用于创建okhttp3.Request对象。</p><p>ServiceMethod对象包含了网络请求的相关信息，包括RequestFactory对象、CallAdapter对象和ResponseConverter对象。OkHttpCall对象则负责执行网络请求，并将结果传递给CallAdapter对象进行处理。CallAdapter对象最终将结果转换成Java对象并返回给调用者。</p><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>在前面的代码中，我们已经看到了动态代理的使用。在Retrofit中，我们使用动态代理来实现注解解析和网络请求的生成。动态代理是一种机制，通过它我们可以在运行时创建一个代理对象，该代理对象会代替原始对象来执行方法调用。</p><p>在Retrofit中，我们使用动态代理来创建一个实现接口的代理对象。当我们调用代理对象的方法时，代理对象会调用InvocationHandler.invoke方法，该方法中实现了注解解析和网络请求的生成。因此，我们可以将网络请求的代码封装在接口中，使得我们的代码更加简洁和易于阅读。</p><p>下面是一个使用动态代理的简单示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> java.lang.reflect.*<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HelloWorld</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldImpl</span> : <span class="hljs-type">HelloWorld &#123;</span></span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;Hello, world!&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> proxy = Proxy.newProxyInstance(<br>        DynamicProxyExample::<span class="hljs-keyword">class</span>.java.classLoader,<br>        arrayOf(HelloWorld::<span class="hljs-keyword">class</span>.java),<br>        <span class="hljs-keyword">object</span> : InvocationHandler &#123;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> target: HelloWorld = HelloWorldImpl()<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">(proxy: <span class="hljs-type">Any</span>?, method: <span class="hljs-type">Method</span>?, args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">out</span> <span class="hljs-type">Any</span>&gt;?)</span></span>: Any? &#123;<br>                println(<span class="hljs-string">&quot;Before method execution...&quot;</span>)<br>                <span class="hljs-keyword">val</span> result = method?.invoke(target, *(args ?: emptyArray()))<br>                println(<span class="hljs-string">&quot;After method execution...&quot;</span>)<br>                <span class="hljs-keyword">return</span> result<br>            &#125;<br>        &#125;<br>    ) <span class="hljs-keyword">as</span> HelloWorld<br>    proxy.sayHello()<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个<code>HelloWorld</code>接口和一个<code>HelloWorldImpl</code>实现类。然后，我们使用动态代理创建了一个代理对象，该代理对象实现了<code>HelloWorld</code>接口。在<code>InvocationHandler</code>的<code>invoke</code>方法中，我们首先输出一行日志，然后调用<code>HelloWorldImpl</code>对象的<code>sayHello</code>方法，最后再输出一行日志。当我们调用代理对象的<code>sayHello</code>方法时，代理对象会调用<code>InvocationHandler.invoke</code>方法，从而实现了在方法执行前后输出日志的功能。动态代理是一种非常强大的机制，可以用于实现很多功能，如性能分析、日志记录、事务管理等。在Retrofit中，我们使用动态代理来实现注解解析和网络请求的生成，从而使得我们的代码更加简洁和易于阅读。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 流式布局TagFlowLayout</title>
    <link href="/2022/07/25/Android-%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80TagFlowLayout/"/>
    <url>/2022/07/25/Android-%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80TagFlowLayout/</url>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>这是一个Android流式布局，根据鸿翔大神之前写的<a href="https://github.com/hongyangAndroid/FlowLayout">FlowLayout</a>设计思路结合<code>Material</code>库中的<code>ChipGroup</code>设计架构衍生而来，全新的流式布局<a href="https://github.com/smallmarker/TagFlowLayout">TagFlowLayout</a>组件</strong></p><h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><p><img src="tagflowlayout_demo.gif" alt="tagflowlayout_demo"></p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="setter"><a href="#setter" class="headerlink" title="setter"></a>setter</h4><table><thead><tr><th align="center">方法名称</th><th align="center">作用</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center"><code>setTagSpacingHorizontal(@Dimension tagSpacingHorizontal: Int)</code></td><td align="center">Tag间的水平间距</td><td align="center"><code>setTagSpacingHorizontal(24)</code></td></tr><tr><td align="center"><code>setTagSpacingVertical(@Dimension tagSpacingVertical: Int)</code></td><td align="center">Tag间的垂直间距</td><td align="center"><code>setTagSpacingVertical(24)</code></td></tr><tr><td align="center"><code>setSingleLine(singleLine: Boolean)</code></td><td align="center">是否开启单行模式（默认false）</td><td align="center"><code>setSingleLine(true)</code></td></tr><tr><td align="center"><code>setSingleSelection(singleSelection: Boolean)</code></td><td align="center">是否开启单选模式（默认false）</td><td align="center"><code>setSingleSelection(true)</code></td></tr><tr><td align="center"><code>setSelectionRequired(selectionRequired: Boolean)</code></td><td align="center">是否为必选项（默认false</td><td align="center"><code>setSelectionRequired(true)</code></td></tr><tr><td align="center"><code>setSelectMax(selectMax: Int)</code></td><td align="center">最大选择数量（&lt;=0为无效值</td><td align="center"><code>setSelectMax(10)</code></td></tr><tr><td align="center"><code>setOnTagClickListener(tagClickListener: TagClickListener)</code></td><td align="center">设置Tag点击事件</td><td align="center"><code>setOnTagClickListener &#123; view, position, parent -&gt; &#125;</code></td></tr><tr><td align="center"><code>setCheckedChangedListener(checkedChangedListener: CheckedChangedListener)</code></td><td align="center">设置Tag状态变更监听事件</td><td align="center"><code>setCheckedChangedListener &#123; group, checkedIds -&gt; &#125;</code></td></tr></tbody></table><h4 id="getter"><a href="#getter" class="headerlink" title="getter"></a>getter</h4><table><thead><tr><th align="center">方法名称</th><th align="center">作用</th><th align="center">返回类型</th></tr></thead><tbody><tr><td align="center"><code>isSelectMax()</code></td><td align="center">是否达到最大的选择数量</td><td align="center"><code>Boolean</code></td></tr><tr><td align="center"><code>clearCheck()</code></td><td align="center">清除所有选中数据</td><td align="center"><code>void</code></td></tr><tr><td align="center"><code>getCheckedTagOrder()</code></td><td align="center">获取选中单选下标</td><td align="center"><code>Int</code></td></tr><tr><td align="center"><code>getCheckedTagOrders()</code></td><td align="center">获取选中集合下标组</td><td align="center"><code>List&lt;Int&gt;</code></td></tr></tbody></table><h4 id="Attributes属性"><a href="#Attributes属性" class="headerlink" title="Attributes属性"></a>Attributes属性</h4><table><thead><tr><th align="center">属性名称</th><th align="center">作用</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center"><code>app:tagSpacing</code></td><td align="center">Tag间的间距</td><td align="center"><code>app:tagSpacing=&quot;24dp&quot;</code></td></tr><tr><td align="center"><code>app:tagSpacingHorizontal</code></td><td align="center">Tag间的水平间距</td><td align="center"><code>app:tagSpacingHorizontal=&quot;24dp&quot;</code></td></tr><tr><td align="center"><code>app:tagSpacingVertical</code></td><td align="center">Tag间的垂直间距</td><td align="center"><code>app:tagSpacingVertical=&quot;24dp&quot;</code></td></tr><tr><td align="center"><code>app:singleLine</code></td><td align="center">是否开启单行模式（默认false）</td><td align="center"><code>app:singleLine=&quot;true&quot;</code></td></tr><tr><td align="center"><code>app:singleSelection</code></td><td align="center">是否开启单选模式（默认false）</td><td align="center"><code>app:是否开启单选模式=&quot;true&quot;</code></td></tr><tr><td align="center"><code>app:selectionRequired</code></td><td align="center">是否为必选项（默认false）</td><td align="center"><code>app:selectionRequired=&quot;true&quot;</code></td></tr><tr><td align="center"><code>app:selectMax</code></td><td align="center">最大选择数量（&lt;=0为无效值）</td><td align="center"><code>app:selectMax=&quot;10&quot;</code></td></tr></tbody></table><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">dependencies &#123;<br>    <span class="hljs-keyword">implementation</span> <span class="hljs-string">&#x27;io.github.smallmarker:tagflowlayout:1.0&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;com.smallmarker.tagflowlayout.TagFlowLayout<br>            android:<span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;@+id/tag_flow_layout&quot;</span><br>            android:<span class="hljs-attribute">layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span><br>            android:<span class="hljs-attribute">layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span><br>            app:<span class="hljs-attribute">tagSpacing</span>=<span class="hljs-string">&quot;16dp&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><h3 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h3><h4 id="方法属性"><a href="#方法属性" class="headerlink" title="方法属性"></a>方法属性</h4><ul><li>创建Adapter：<code>TagFlowAdapter.create(dataList)</code></li><li>设置Tag：<code>setView(parent: TagFlowLayout, position: Int, t: T)</code></li><li>设置Tag状态：<code>setChecked(position: Int, t: T)</code></li><li>监听状态变化：<code>setCheckedChanged(isChecked: Boolean, position: Int, view: View)</code></li><li>刷新适配器：<code>notifyDataSetChange()</code></li></ul><h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h4><ul><li><strong>设置数据</strong></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 设置Adapter</span><br>binding<span class="hljs-selector-class">.tagFlowLayout</span><span class="hljs-selector-class">.adapter</span> = TagFlowAdapter<span class="hljs-selector-class">.create</span>(dataList) &#123;<br>    setView &#123; parent, <span class="hljs-attribute">position</span>, t -&gt;<br>        <span class="hljs-built_in">TextView</span>(parent.context)<span class="hljs-selector-class">.apply</span> &#123;<br>            text = t<br>            <span class="hljs-built_in">setBackgroundResource</span>(R<span class="hljs-selector-class">.drawable</span>.bg_tag_selector)<br>            <span class="hljs-built_in">setPadding</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>选中状态</strong></li></ul><p>支持通过<code>state=checked</code>来控制选中和取消</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">selector</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">android:state_checked</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">shape</span> <span class="hljs-attr">android:shape</span>=<span class="hljs-string">&quot;rectangle&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">corners</span> <span class="hljs-attr">android:radius</span>=<span class="hljs-string">&quot;6dp&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">stroke</span> <span class="hljs-attr">android:width</span>=<span class="hljs-string">&quot;1.2dp&quot;</span> <span class="hljs-attr">android:color</span>=<span class="hljs-string">&quot;#374D9D&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">shape</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">shape</span> <span class="hljs-attr">android:shape</span>=<span class="hljs-string">&quot;rectangle&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">corners</span> <span class="hljs-attr">android:radius</span>=<span class="hljs-string">&quot;6dp&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">stroke</span> <span class="hljs-attr">android:width</span>=<span class="hljs-string">&quot;1.2dp&quot;</span> <span class="hljs-attr">android:color</span>=<span class="hljs-string">&quot;#C4C7D1&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">shape</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">selector</span>&gt;</span><br></code></pre></td></tr></table></figure><p>也可以自己在<code>Adapter</code> 的<code>setCheckedChanged</code>处理显示</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">setCheckedChanged &#123; isChecked, <span class="hljs-attribute">position</span>, view -&gt;<br>                Log<span class="hljs-selector-class">.d</span>(<span class="hljs-string">&quot;TAG&quot;</span>, <span class="hljs-string">&quot;当前TAG状态：$&#123;isChecked&#125;, $&#123;position&#125;&quot;</span>)<br>                view<span class="hljs-selector-class">.setBackgroundColor</span>(<span class="hljs-keyword">if</span> (isChecked) &#123;<br>                    Color<span class="hljs-selector-class">.RED</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    Color<span class="hljs-selector-class">.GRAY</span><br>                &#125;)<br>            &#125;<br></code></pre></td></tr></table></figure><ul><li><strong>事件</strong></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 点击事件</span><br>binding<span class="hljs-selector-class">.tagFlowLayout</span><span class="hljs-selector-class">.setOnTagClickListener</span> &#123; view, <span class="hljs-attribute">position</span>, parent -&gt;<br>    Log<span class="hljs-selector-class">.d</span>(<span class="hljs-string">&quot;TAG&quot;</span>, <span class="hljs-string">&quot;当前选中TAG： $&#123;position&#125;&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 状态监听</span><br>binding<span class="hljs-selector-class">.tagFlowLayout</span><span class="hljs-selector-class">.setCheckedChangedListener</span> &#123; group, checkedIds -&gt;<br>    binding<span class="hljs-selector-class">.tvTip</span><span class="hljs-selector-class">.text</span> = <span class="hljs-string">&quot;当前选中TAG序号：$&#123;checkedIds&#125;&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>偶然发现<code>material</code>库中<code>chip</code>组件，其通过<code>ChipGroup</code>实现流式布局的设计，加上很早之前有用过鸿神的<code>FlowLayout</code>库，所以就在此基础上写了一个新的流式布局组件，该组件在类的命名上还是沿用了鸿神之前的<code>FlowLayout</code>，为了不依赖<code>material</code>库的较高版本的限制，故将需要用到的类抽取使用，做兼容处理</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>Android组件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android AGP升级后导致APK体积增大</title>
    <link href="/2022/06/10/Android-AGP%E5%8D%87%E7%BA%A7%E5%90%8E%E5%AF%BC%E8%87%B4APK%E4%BD%93%E7%A7%AF%E5%A2%9E%E5%A4%A7/"/>
    <url>/2022/06/10/Android-AGP%E5%8D%87%E7%BA%A7%E5%90%8E%E5%AF%BC%E8%87%B4APK%E4%BD%93%E7%A7%AF%E5%A2%9E%E5%A4%A7/</url>
    
    <content type="html"><![CDATA[<p><strong>项目AGP升级至7.0+后发现打出来release包的体积比之前增加近一倍，经过查询官方文档得知在AGP3.6.0时的行为变更上：默认情况下，原生库以未压缩的形式打包。</strong></p><p>在构建应用时，插件现在默认会将 <code>extractNativeLibs</code> 设置为<code> &quot;false&quot;</code>也就是说，您的原生库将保持页面对齐状态并以未压缩的形式打包。虽然这样会增加上传大小，但您的用户会从以下优势中受益：</p><ul><li>减小应用安装大小，因为平台可以直接从已安装的 APK 访问原生库，而无需创建库的副本。</li><li>减小下载文件大小，因为在 APK 或 <code>Android App Bundle</code> 中添加未压缩的原生库通常可提高 Play 商店的压缩率。</li></ul><p>如果您希望 <code>Android Gradle</code> 插件改为打包压缩后的原生库，请在应用的清单中添加以下代码：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-built_in">application</span><br>    android:extractNativeLibs=<span class="hljs-string">&quot;true&quot;</span><br>    ... &gt;<br>&lt;/<span class="hljs-built_in">application</span>&gt;<br></code></pre></td></tr></table></figure><p><strong>但是从 AGP 4.2.0 开始，<code>extractNativeLibs</code> 清单属性已被 DSL 选项 <code>useLegacyPackaging</code> 取代。 您应该使用应用的 <code>build.gradle</code> 文件中的 <code>useLegacyPackaging</code>（而非清单文件中的 <code>extractNativeLibs</code>）来配置原生库压缩行为：</strong></p><h5 id="使用-DSL-打包压缩后的原生库"><a href="#使用-DSL-打包压缩后的原生库" class="headerlink" title="使用 DSL 打包压缩后的原生库"></a>使用 DSL 打包压缩后的原生库</h5><p>官方建议以未压缩的形式打包原生库，因为这会减小应用安装大小，缩减应用下载大小，并缩短用户的应用加载时间。不过，如果您希望 <code>Android Gradle</code> 插件在构建应用时打包压缩后的原生库，请在应用的 <code>build.gradle</code> 文件中将 <code>useLegacyPackaging</code>设置为 <code>true</code>：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">android</span> &#123;<br>    <span class="hljs-keyword">packagingOptions</span> &#123;<br>        <span class="hljs-keyword">jniLibs</span> &#123;<br>            useLegacyPackaging <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：<code>useLegacyPackaging</code> 标记会替换 <code>extractNativeLibs</code> 清单属性。默认情况下，原生库以未压缩的形式打包。</strong></p><p>官方文档参考：</p><p><a href="https://developer.android.com/studio/releases/gradle-plugin?buildsystem=ndk-build#extractNativeLibs">https://developer.android.com/studio/releases/gradle-plugin?buildsystem=ndk-build#extractNativeLibs</a></p><p><a href="https://developer.android.com/studio/releases/gradle-plugin?buildsystem=ndk-build#compress-native-libs-dsl">https://developer.android.com/studio/releases/gradle-plugin?buildsystem=ndk-build#compress-native-libs-dsl</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Android奇遇记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
