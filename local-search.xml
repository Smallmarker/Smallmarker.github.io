<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Retrofit 核心源码分析（二）- 网络请求和响应处理</title>
    <link href="/2023/03/08/Retrofit%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E5%A4%84%E7%90%86/"/>
    <url>/2023/03/08/Retrofit%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p><strong>在上一篇文章中，我们详细分析了 Retrofit 中的注解解析和动态代理实现，本篇文章将继续深入研究 Retrofit 的核心源码，重点分析 Retrofit 如何进行网络请求和响应处理。</strong></p><h4 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h4><p>在使用 Retrofit 发起网络请求时，我们可以通过定义一个接口并使用 Retrofit 的注解来描述这个接口中的请求，Retrofit 会自动生成一个实现该接口的代理对象。当我们调用这个代理对象的方法时，Retrofit 会根据注解的描述构建一个 Request 对象，并使用 OkHttp 将这个 Request 发送出去。</p><p>在 Retrofit 中，我们可以通过 <code>Retrofit#execute</code> 或 <code>Retrofit#enqueue</code> 方法来发送请求。这两个方法的区别在于，<code>execute</code> 方法会阻塞当前线程直到请求完成，而 <code>enqueue</code> 方法会将请求加入到 OkHttp 的请求队列中，并在请求完成时通过回调通知我们。</p><p>我们先来看一下 <code>execute</code> 方法的实现：</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vbscript"><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-keyword">execute</span>(<span class="hljs-keyword">Call</span>&lt;T&gt; <span class="hljs-keyword">call</span>) throws IOException &#123;<br>  Utils.validateServiceInterface(<span class="hljs-keyword">call</span>.<span class="hljs-built_in">request</span>().tag(), <span class="hljs-keyword">call</span>.<span class="hljs-built_in">request</span>().url().<span class="hljs-keyword">to</span><span class="hljs-built_in">String</span>());<br>  return (T) callAdapter(<span class="hljs-keyword">call</span>, <span class="hljs-keyword">call</span>.<span class="hljs-built_in">request</span>().tag()).adapt(<span class="hljs-keyword">call</span>).<span class="hljs-keyword">execute</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个方法中，首先会对接口进行校验，确保这个接口是有效的。然后我们会根据请求的 Tag 和 URL 来获取适配器<code>callAdapter</code>，并使用适配器来执行请求。</p><p>适配器的作用是将请求的参数适配成 OkHttp 能够识别的形式，并将 OkHttp 的响应适配成我们需要的形式。Retrofit 提供了一系列的适配器，包括 Call 适配器、RxJava 适配器、CompletableFuture 适配器等。</p><p>我们来看一下 <code>callAdapter</code> 方法的实现：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> CallAdapter&lt;?, ?&gt; call<span class="hljs-constructor">Adapter(Call&lt;?&gt; <span class="hljs-params">call</span>, Object <span class="hljs-params">tag</span>)</span> &#123;<br>  Type responseType = call.request<span class="hljs-literal">()</span>.<span class="hljs-keyword">method</span><span class="hljs-literal">()</span>.equals(<span class="hljs-string">&quot;HEAD&quot;</span>)<br>      ? <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Void</span>.</span></span><span class="hljs-keyword">class</span><br>      : get<span class="hljs-constructor">ParameterUpperBound(0, (ParameterizedType)</span> call.request<span class="hljs-literal">()</span>.tag<span class="hljs-literal">()</span>);<br>  return call<span class="hljs-constructor">Adapter(<span class="hljs-params">tag</span>, <span class="hljs-params">responseType</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个方法中，我们首先根据请求的方法来判断响应的类型，如果是 HEAD 方法，那么响应的类型就是 Void；否则我们会通过反射来获取请求的响应类型，并使用这个响应类型来获取适配器。</p><p>获取适配器的方法是 <code>callAdapter</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart">public &lt;R, T&gt; CallAdapter&lt;R, T&gt; callAdapter(<span class="hljs-built_in">Object</span> tag, <span class="hljs-built_in">Type</span> returnType) &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">for</span> (CallAdapter.Factory <span class="hljs-keyword">factory</span> : adapterFactories) &#123;<br>    CallAdapter&lt;?, ?&gt; adapter = <span class="hljs-keyword">factory</span>.<span class="hljs-keyword">get</span>(returnType, annotations, <span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">if</span> (adapter != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> (CallAdapter&lt;R, T&gt;) adapter;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个方法中，我们会遍历所有的适配器工厂，尝试获取适配器。在获取适配器时，我们会将请求的响应类型、注解和 Retrofit 实例作为参数传入。每个适配器工厂都会判断这些参数是否符合自己的适配条件，如果符合，就返回一个适配器实例，否则返回 null。在遍历完所有的适配器工厂之后，如果还没有获取到适配器，那么就会抛出一个异常。</p><p>获取到适配器之后，我们就可以使用适配器来执行请求了。在适配器中，我们会将请求参数转换成 OkHttp 的 Request 对象，并将 OkHttp 的 Response 对象转换成我们需要的响应类型。具体的实现可以参考 Retrofit 提供的 <code>CallAdapter</code> 接口。</p><p>对于 <code>enqueue</code> 方法，我们可以先来看一下 <code>enqueue</code> 方法的实现：</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vbscript"><span class="hljs-keyword">public</span> &lt;T&gt; void enqueue(<span class="hljs-keyword">Call</span>&lt;T&gt; <span class="hljs-keyword">call</span>, Callback&lt;T&gt; callback) &#123;<br>  Utils.validateServiceInterface(<span class="hljs-keyword">call</span>.<span class="hljs-built_in">request</span>().tag(), <span class="hljs-keyword">call</span>.<span class="hljs-built_in">request</span>().url().<span class="hljs-keyword">to</span><span class="hljs-built_in">String</span>());<br>  callAdapter(<span class="hljs-keyword">call</span>, <span class="hljs-keyword">call</span>.<span class="hljs-built_in">request</span>().tag()).adapt(<span class="hljs-keyword">call</span>).enqueue(<span class="hljs-keyword">new</span> CallbackRunnable&lt;&gt;(callback));<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个方法中，我们首先进行接口校验，然后根据请求的 Tag 和 URL 来获取适配器，并使用适配器来执行请求。不同的是，在 <code>enqueue</code> 方法中，我们将一个 Callback 对象作为参数传入适配器的 <code>enqueue</code> 方法中，以便在请求完成后回调通知我们。</p><p>在适配器中，我们可以看到 <code>enqueue</code> 方法的实现：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public void enqueue(final Callback&lt;T&gt; callback) &#123;<br>  delegate.enqueue(<span class="hljs-keyword">new</span> Callback&lt;Response&lt;T&gt;&gt;<span class="hljs-literal">()</span> &#123;<br>    @Override public void on<span class="hljs-constructor">Response(Call&lt;Response&lt;T&gt;&gt; <span class="hljs-params">call</span>, Response&lt;Response&lt;T&gt;&gt; <span class="hljs-params">response</span>)</span> &#123;<br>      Response&lt;T&gt; body;<br>      <span class="hljs-keyword">try</span> &#123;<br>        body = response.body<span class="hljs-literal">()</span>;<br>      &#125; catch (Throwable t) &#123;<br>        <span class="hljs-keyword">if</span> (response.code<span class="hljs-literal">()</span><span class="hljs-operator"> == </span><span class="hljs-number">204</span>) &#123;<br>          body = null;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          callback.on<span class="hljs-constructor">Failure(<span class="hljs-params">call</span>, <span class="hljs-params">t</span>)</span>;<br>          return;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (response.is<span class="hljs-constructor">Successful()</span>) &#123;<br>        callback.on<span class="hljs-constructor">Response(<span class="hljs-params">call</span>, Response.<span class="hljs-params">success</span>(<span class="hljs-params">body</span>, <span class="hljs-params">response</span>.<span class="hljs-params">raw</span>()</span>));<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        callback.on<span class="hljs-constructor">Failure(<span class="hljs-params">call</span>, Response.<span class="hljs-params">error</span>(<span class="hljs-params">response</span>.<span class="hljs-params">errorBody</span>()</span>, response.raw<span class="hljs-literal">()</span>));<br>      &#125;<br>    &#125;<br><br>    @Override public void on<span class="hljs-constructor">Failure(Call&lt;Response&lt;T&gt;&gt; <span class="hljs-params">call</span>, Throwable <span class="hljs-params">t</span>)</span> &#123;<br>      callback.on<span class="hljs-constructor">Failure(<span class="hljs-params">call</span>, <span class="hljs-params">t</span>)</span>;<br>    &#125;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个方法中，我们会将传入的 Callback 对象转换成一个 <code>Callback&lt;Response&lt;T&gt;&gt;</code> 对象，并使用这个对象来调用 OkHttp 的 enqueue 方法。在请求完成后，我们会将 OkHttp 的 Response 对象转换成 Retrofit 的 Response 对象，并根据响应码来判断请求的结果。如果响应码表示请求成功，那么我们就调用 Callback 对象的 <code>onResponse</code> 方法；否则就调用 Callback 对象的 <code>onFailure</code> 方法。</p><h4 id="响应处理"><a href="#响应处理" class="headerlink" title="响应处理"></a>响应处理</h4><p>在 Retrofit 中，我们可以通过定义一个接口并使用注解来描述我们期望的请求格式和响应格式。例如，我们可以通过 <code>@GET</code> 注解来描述一个 GET 请求，使用 <code>@Query</code> 注解来描述请求参数，使用 <code>@Body</code> 注解来描述请求体，使用 <code>@Headers</code> 注解来描述请求头等。</p><p>在执行请求时，Retrofit 会根据这些注解来自动生成一个对应的请求对象，并将请求对象转换成 OkHttp 的 Request 对象。在接收响应时，Retrofit 会将 OkHttp 的 Response 对象转换成一个对应的响应对象，并将响应对象中的数据转换成我们需要的数据类型。这些转换工作是通过 Retrofit 的转换器来完成的，Retrofit 中默认提供了两个转换器：<code>GsonConverterFactory</code> 和 <code>JacksonConverterFactory</code>。我们也可以自定义一个转换器来实现我们期望的数据转换。</p><p>在 Retrofit 类的构造方法中，我们可以看到 Retrofit 默认使用了 <code>Platform.get()</code> 方法来获取当前运行平台的默认转换器工厂，并将其添加到 <code>converterFactories</code> 中。然后，我们可以使用 <code>addConverterFactory</code> 方法来添加自定义的转换器工厂。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Retrofit</span>(<span class="hljs-params">Builder builder</span>)</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">if</span> (builder.converterFactories == <span class="hljs-literal">null</span>) &#123;<br>    converterFactories.<span class="hljs-keyword">add</span>(Platform.<span class="hljs-keyword">get</span>().defaultConverterFactory());<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    converterFactories.addAll(builder.converterFactories);<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Platform</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>  Converter.<span class="hljs-function">Factory <span class="hljs-title">defaultConverterFactory</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>execute</code>方法中，我们会调用适配器的 adapt 方法来执行请求，并将返回的 Call 对象转换成一个响应对象。在转换过程中，我们会根据响应类型来选择对应的转换器来进行转换。具体的转换实现可以参考 Retrofit 提供的 <code>Converter</code> 接口和 <code>Converter.Factory</code> 接口。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs scala">public &lt;<span class="hljs-type">T</span>&gt; <span class="hljs-type">T</span> execute(<span class="hljs-type">Call</span>&lt;<span class="hljs-type">T</span>&gt; call) <span class="hljs-keyword">throws</span> <span class="hljs-type">IOException</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-type">Response</span>&lt;<span class="hljs-type">T</span>&gt; response = call.execute();<br>  <span class="hljs-keyword">if</span> (response.isSuccessful()) &#123;<br>    <span class="hljs-keyword">return</span> response.body();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-type">Converter</span>&lt;<span class="hljs-type">ResponseBody</span>, <span class="hljs-type">ErrorResponse</span>&gt; converter = retrofit.responseBodyConverter(<br>        <span class="hljs-type">ErrorResponse</span>.<span class="hljs-keyword">class</span>, <span class="hljs-keyword">new</span> <span class="hljs-type">Annotation</span>[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">ApiException</span>(converter.convert(response.errorBody()));<br>  &#125;<br>&#125;<br><br><span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">&quot;unchecked&quot;</span>) <span class="hljs-comment">// Single-interface proxy creation guarded by parameter safety.</span><br>public &lt;<span class="hljs-type">T</span>&gt; <span class="hljs-type">T</span> adapt(<span class="hljs-type">Call</span>&lt;<span class="hljs-type">T</span>&gt; call) &#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">T</span>) <span class="hljs-keyword">new</span> <span class="hljs-type">OkHttpCall</span>&lt;&gt;(requestFactory, callFactory, converter, call);<br>&#125;<br><br>public &lt;<span class="hljs-type">T</span>&gt; <span class="hljs-type">Converter</span>&lt;<span class="hljs-type">ResponseBody</span>, <span class="hljs-type">T</span>&gt; responseBodyConverter(<span class="hljs-type">Type</span> <span class="hljs-class"><span class="hljs-keyword">type</span>, <span class="hljs-title">Annotation</span>[] <span class="hljs-title">annotations</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> nextResponseBodyConverter(<span class="hljs-literal">null</span>, <span class="hljs-class"><span class="hljs-keyword">type</span>, <span class="hljs-title">annotations</span>)</span>;<br>&#125;<br><br>public &lt;<span class="hljs-type">T</span>&gt; <span class="hljs-type">Converter</span>&lt;<span class="hljs-type">ResponseBody</span>, <span class="hljs-type">T</span>&gt; nextResponseBodyConverter(<br>    <span class="hljs-meta">@Nullable</span> <span class="hljs-type">Converter</span>.<span class="hljs-type">Factory</span> skipPast, <span class="hljs-type">Type</span> <span class="hljs-class"><span class="hljs-keyword">type</span>, <span class="hljs-title">Annotation</span>[] <span class="hljs-title">annotations</span>) </span>&#123;<br>  <span class="hljs-type">Objects</span>.requireNonNull(<span class="hljs-class"><span class="hljs-keyword">type</span>, &quot;<span class="hljs-title">type</span> <span class="hljs-title">==</span> <span class="hljs-title">null</span>&quot;)</span>;<br>  <span class="hljs-type">Objects</span>.requireNonNull(annotations, <span class="hljs-string">&quot;annotations == null&quot;</span>);<br><br>  int start = converterFactories.indexOf(skipPast) + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (int i = start, count = converterFactories.size(); i &lt; count; i++) &#123;<br>    <span class="hljs-type">Converter</span>&lt;<span class="hljs-type">ResponseBody</span>, ?&gt; converter =<br>        converterFactories.get(i).responseBodyConverter(<span class="hljs-class"><span class="hljs-keyword">type</span>, <span class="hljs-title">annotations</span>, <span class="hljs-title">this</span>)</span>;<br>    <span class="hljs-keyword">if</span> (converter != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> (<span class="hljs-type">Converter</span>&lt;<span class="hljs-type">ResponseBody</span>, <span class="hljs-type">T</span>&gt;) converter;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">IllegalArgumentException</span>(<br>      <span class="hljs-string">&quot;Could not locate ResponseBody converter for &quot;</span> + <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">+</span> &quot; <span class="hljs-keyword">with</span> <span class="hljs-title">annotations</span> &quot; <span class="hljs-title">+</span> <span class="hljs-title">Arrays</span>.<span class="hljs-title">toString</span>(<span class="hljs-params">annotations</span>))</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上是 Retrofit 中处理响应的核心代码。当我们执行一个请求时，Retrofit 会先将请求转换成 OkHttp 的 Request 对象并发送出去，然后等待响应返回。当响应返回时，Retrofit 会将响应转换成一个响应对象，并将响应对象中的数据转换成我们期望的数据类型。这个过程中，我们可以使用 Retrofit 提供的转换器来自定义数据的转换规则。</p><p>下面是一个示例，演示了如何使用 Retrofit 来发送一个 GET 请求并将响应中的 JSON 数据转换成一个 Java 对象：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> interface ApiService &#123;<br>  @<span class="hljs-keyword">GET</span>(&quot;users/&#123;user&#125;/repos&quot;)<br>  <span class="hljs-keyword">Call</span>&lt;List&lt;Repo&gt;&gt; listRepos(@Path(&quot;user&quot;) String <span class="hljs-keyword">user</span>);<br>&#125;<br><br>Retrofit retrofit = <span class="hljs-built_in">new</span> Retrofit.Builder()<br>    .baseUrl(&quot;https://api.github.com/&quot;)<br>    .addConverterFactory(GsonConverterFactory.<span class="hljs-keyword">create</span>())<br>    .build();<br><br>ApiService apiService = retrofit.<span class="hljs-keyword">create</span>(ApiService.<span class="hljs-keyword">class</span>);<br><span class="hljs-keyword">Call</span>&lt;List&lt;Repo&gt;&gt; <span class="hljs-keyword">call</span> = apiService.listRepos(&quot;smallmarker&quot;);<br>List&lt;Repo&gt; repos = <span class="hljs-keyword">call</span>.<span class="hljs-keyword">execute</span>().body();<br></code></pre></td></tr></table></figure><p>在上面的示例中，我们首先使用 Retrofit 构建器创建一个 Retrofit 实例，并指定了请求的基础 URL 和转换器工厂。然后，我们通过调用 <code>create</code> 方法来创建一个 <code>ApiService</code> 的代理对象。最后，我们调用 <code>listRepos</code> 方法来发送一个 GET 请求。</p><p>在上面的示例中，我们使用了 Retrofit 的 <code>GsonConverterFactory</code> 来将响应体中的 JSON 数据转换成 Java 对象。具体实现可以查看 Retrofit 提供的 <code>GsonConverterFactory</code> 类。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> final <span class="hljs-keyword">class</span> <span class="hljs-title class_">GsonConverterFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Converter.Factory</span> &#123;<br>  <span class="hljs-keyword">private</span> final <span class="hljs-title class_">Gson</span> gson;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-title class_">GsonConverterFactory</span>(<span class="hljs-title class_">Gson</span> gson) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">gson</span> = gson;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">GsonConverterFactory</span> <span class="hljs-title function_">create</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">create</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Gson</span>());<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">GsonConverterFactory</span> <span class="hljs-title function_">create</span>(<span class="hljs-params">Gson gson</span>) &#123;<br>    <span class="hljs-keyword">if</span> (gson == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;gson == null&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GsonConverterFactory</span>(gson);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-meta">@Nullable</span> <span class="hljs-title class_">Converter</span>&lt;<span class="hljs-title class_">ResponseBody</span>, ?&gt; <span class="hljs-title function_">responseBodyConverter</span>(<span class="hljs-params">Type <span class="hljs-keyword">type</span>, Annotation[] annotations, Retrofit retrofit</span>) &#123;<br>    <span class="hljs-title class_">TypeAdapter</span>&lt;?&gt; adapter = gson.<span class="hljs-title function_">getAdapter</span>(<span class="hljs-title class_">TypeToken</span>.<span class="hljs-title function_">get</span>(<span class="hljs-keyword">type</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GsonResponseBodyConverter</span>&lt;&gt;(gson, adapter);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-meta">@Nullable</span> <span class="hljs-title class_">Converter</span>&lt;?, <span class="hljs-title class_">RequestBody</span>&gt; <span class="hljs-title function_">requestBodyConverter</span>(<span class="hljs-params">Type <span class="hljs-keyword">type</span>, Annotation[] parameterAnnotations,</span><br><span class="hljs-params">                                                                  Annotation[] methodAnnotations, Retrofit retrofit</span>) &#123;<br>    <span class="hljs-title class_">TypeAdapter</span>&lt;?&gt; adapter = gson.<span class="hljs-title function_">getAdapter</span>(<span class="hljs-title class_">TypeToken</span>.<span class="hljs-title function_">get</span>(<span class="hljs-keyword">type</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GsonRequestBodyConverter</span>&lt;&gt;(gson, adapter);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，<code>GsonConverterFactory</code> 继承了 Retrofit 的 <code>Converter.Factory</code> 类，并重写了其中的 <code>responseBodyConverter</code> 方法和 <code>requestBodyConverter</code> 方法。在 <code>responseBodyConverter</code> 方法中，我们将响应体中的 JSON 数据转换成 Java 对象，而在 <code>requestBodyConverter</code> 方法中，我们将 Java 对象转换成请求体中的 JSON 数据。</p><p>除了 <code>GsonConverterFactory</code> 以外，Retrofit 还提供了其他的转换器，如 <code>JacksonConverterFactory、MoshiConverterFactory</code> 等，我们可以根据需要选择适合自己的转换器。</p><p>总的来说，Retrofit 中网络请求和响应处理的核心代码非常简洁明了。我们只需要通过定义接口来描述请求和响应，然后使用 Retrofit 的动态代理机制来将接口转换成一个实际的实现类，并通过 Retrofit 的配置来指定请求和响应的转换器即可。这种方式大大简化了网络请求的流程，使得我们可以更加专注于业务逻辑的处理。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android 源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Retrofit 核心源码分析（一）- 注解解析和动态代理</title>
    <link href="/2023/03/07/Retrofit%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89-%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <url>/2023/03/07/Retrofit%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89-%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p><strong>Retrofit是目前Android平台上比较流行的网络请求框架之一，它提供了一种简洁、灵活的方式来处理HTTP请求和响应。Retrofit的设计目的是使网络请求的代码更加容易编写和阅读，同时还提供了许多有用的特性，如注解解析、动态代理等。在本文中，我们将对Retrofit的注解解析和动态代理进行详细的分析。</strong></p><h4 id="注解解析"><a href="#注解解析" class="headerlink" title="注解解析"></a>注解解析</h4><p>在使用Retrofit时，我们通常会定义一个接口，该接口用于描述我们要请求的API接口。在这个接口中，我们可以使用注解来描述API的各个方面，如HTTP方法、请求URL、请求参数等。Retrofit会根据这些注解来生成相应的网络请求代码。下面是一个示例：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">interface</span> <span class="hljs-selector-tag">GitHubService</span> &#123;<br>    <span class="hljs-variable">@GET</span>(<span class="hljs-string">&quot;users/&#123;user&#125;/repos&quot;</span>)<br>    fun listRepos(<span class="hljs-variable">@Path</span>(<span class="hljs-string">&quot;user&quot;</span>) <span class="hljs-attribute">user</span>: String): Call&lt;List&lt;Repo&gt;&gt;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个示例中，@GET注解表示这是一个HTTP GET请求，”users/{user}/repos”表示请求的URL，@Path(“user”)表示请求URL中的参数。Retrofit会解析这些注解，并生成相应的网络请求代码。</p><p>Retrofit中的注解解析是通过Retrofit.Builder中的retrofit2.Retrofit#create方法实现的。这个方法会返回一个代理对象，该代理对象会在调用接口方法时解析注解并生成相应的网络请求。</p><p>下面是retrofit2.Retrofit#create方法的核心代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Utils</span>.</span></span>validate<span class="hljs-constructor">ServiceInterface(<span class="hljs-params">service</span>)</span>;<br>    <span class="hljs-keyword">if</span> (validateEagerly) &#123;<br>        eagerly<span class="hljs-constructor">ValidateMethods(<span class="hljs-params">service</span>)</span>;<br>    &#125;<br>    return (T) <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Proxy</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">ProxyInstance(<span class="hljs-params">service</span>.<span class="hljs-params">getClassLoader</span>()</span>, <span class="hljs-keyword">new</span> Class&lt;?&gt;<span class="hljs-literal">[]</span> &#123; service &#125;,<br>            <span class="hljs-keyword">new</span> <span class="hljs-constructor">InvocationHandler()</span> &#123;<br>                <span class="hljs-keyword">private</span> final Platform platform = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Platform</span>.</span></span>get<span class="hljs-literal">()</span>;<br><br>                @Override<br>                public Object invoke(Object proxy, Method <span class="hljs-keyword">method</span>, Object<span class="hljs-literal">[]</span> args)<br>                        throws Throwable &#123;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">method</span>.get<span class="hljs-constructor">DeclaringClass()</span><span class="hljs-operator"> == </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span><span class="hljs-keyword">class</span>) &#123;<br>                        return <span class="hljs-keyword">method</span>.invoke(this, args);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (platform.is<span class="hljs-constructor">DefaultMethod(<span class="hljs-params">method</span>)</span>) &#123;<br>                        return platform.invoke<span class="hljs-constructor">DefaultMethod(<span class="hljs-params">method</span>, <span class="hljs-params">service</span>, <span class="hljs-params">proxy</span>, <span class="hljs-params">args</span>)</span>;<br>                    &#125;<br>                    ServiceMethod&lt;Object, Object&gt; serviceMethod =<br>                            (ServiceMethod&lt;Object, Object&gt;) load<span class="hljs-constructor">ServiceMethod(<span class="hljs-params">method</span>)</span>;<br>                    OkHttpCall&lt;Object&gt; okHttpCall = <span class="hljs-keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);<br>                    return serviceMethod.callAdapter.adapt(okHttpCall);<br>                &#125;<br>            &#125;);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>该方法首先会验证接口是否满足要求，然后会返回一个代理对象。这个代理对象实现了接口中的所有方法，并在调用方法时解析注解并生成相应的网络请求。</p><p>我们可以看到，代理对象的实现是通过java.lang.reflect.Proxy类实现的。Proxy.newProxyInstance方法会返回一个代理对象，该代理对象实现了指定接口中的所有方法。当我们调用代理对象的方法时，代理对象会调用InvocationHandler.invoke方法，该方法中实现了注解解析和网络请求的生成。</p><p>在InvocationHandler.invoke方法中，首先会判断是否调用了Object类的方法，如果是，则直接返回该方法的执行结果。如果不是，则进一步判断是否调用了接口的默认方法，如果是，则使用Platform类调用默认方法。否则，就调用loadServiceMethod方法来解析注解并生成网络请求。</p><p>loadServiceMethod方法会首先从缓存中获取ServiceMethod对象，如果缓存中没有，则创建一个新的ServiceMethod对象。ServiceMethod对象包含了网络请求的相关信息，如HTTP方法、请求URL、请求参数等。ServiceMethod对象的创建是通过ServiceMethod.Builder类实现的，该类会解析接口方法上的注解并生成相应的网络请求。</p><p>下面是ServiceMethod.Builder类的核心代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> ServiceMethod <span class="hljs-title">build</span>()</span> &#123;<br>    callAdapter = createCallAdapter();<br>    responseType = callAdapter.responseType();<br>    <span class="hljs-keyword">if</span> (responseType == Response.<span class="hljs-keyword">class</span> || responseType == okhttp3.Response.<span class="hljs-keyword">class</span>) &#123;<br>        <span class="hljs-keyword">throw</span> methodError(<span class="hljs-string">&quot;&#x27;&quot;</span><br>                + Utils.getRawType(responseType).getName()<br>                + <span class="hljs-string">&quot;&#x27; is not a valid response body type. Did you mean ResponseBody?&quot;</span>);<br>    &#125;<br>    responseConverter = createResponseConverter();<br>    RequestFactory requestFactory = createRequestFactory();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ServiceMethod&lt;&gt;(requestFactory, callAdapter, responseConverter);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在ServiceMethod.Builder类中，首先会创建一个CallAdapter对象，该对象用于处理网络请求的结果。然后会检查responseType是否是Response或okhttp3.Response类型，如果是，则抛出异常。接下来，会创建一个ResponseConverter对象，该对象用于将网络请求的结果转换成Java对象。最后，会创建一个RequestFactory对象，该对象用于创建okhttp3.Request对象。</p><p>ServiceMethod对象包含了网络请求的相关信息，包括RequestFactory对象、CallAdapter对象和ResponseConverter对象。OkHttpCall对象则负责执行网络请求，并将结果传递给CallAdapter对象进行处理。CallAdapter对象最终将结果转换成Java对象并返回给调用者。</p><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>在前面的代码中，我们已经看到了动态代理的使用。在Retrofit中，我们使用动态代理来实现注解解析和网络请求的生成。动态代理是一种机制，通过它我们可以在运行时创建一个代理对象，该代理对象会代替原始对象来执行方法调用。</p><p>在Retrofit中，我们使用动态代理来创建一个实现接口的代理对象。当我们调用代理对象的方法时，代理对象会调用InvocationHandler.invoke方法，该方法中实现了注解解析和网络请求的生成。因此，我们可以将网络请求的代码封装在接口中，使得我们的代码更加简洁和易于阅读。</p><p>下面是一个使用动态代理的简单示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> java.lang.reflect.*<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HelloWorld</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldImpl</span> : <span class="hljs-type">HelloWorld &#123;</span></span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;Hello, world!&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> proxy = Proxy.newProxyInstance(<br>        DynamicProxyExample::<span class="hljs-keyword">class</span>.java.classLoader,<br>        arrayOf(HelloWorld::<span class="hljs-keyword">class</span>.java),<br>        <span class="hljs-keyword">object</span> : InvocationHandler &#123;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> target: HelloWorld = HelloWorldImpl()<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">(proxy: <span class="hljs-type">Any</span>?, method: <span class="hljs-type">Method</span>?, args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">out</span> <span class="hljs-type">Any</span>&gt;?)</span></span>: Any? &#123;<br>                println(<span class="hljs-string">&quot;Before method execution...&quot;</span>)<br>                <span class="hljs-keyword">val</span> result = method?.invoke(target, *(args ?: emptyArray()))<br>                println(<span class="hljs-string">&quot;After method execution...&quot;</span>)<br>                <span class="hljs-keyword">return</span> result<br>            &#125;<br>        &#125;<br>    ) <span class="hljs-keyword">as</span> HelloWorld<br>    proxy.sayHello()<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个<code>HelloWorld</code>接口和一个<code>HelloWorldImpl</code>实现类。然后，我们使用动态代理创建了一个代理对象，该代理对象实现了<code>HelloWorld</code>接口。在<code>InvocationHandler</code>的<code>invoke</code>方法中，我们首先输出一行日志，然后调用<code>HelloWorldImpl</code>对象的<code>sayHello</code>方法，最后再输出一行日志。当我们调用代理对象的<code>sayHello</code>方法时，代理对象会调用<code>InvocationHandler.invoke</code>方法，从而实现了在方法执行前后输出日志的功能。动态代理是一种非常强大的机制，可以用于实现很多功能，如性能分析、日志记录、事务管理等。在Retrofit中，我们使用动态代理来实现注解解析和网络请求的生成，从而使得我们的代码更加简洁和易于阅读。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android 源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 流式布局TagFlowLayout</title>
    <link href="/2022/07/25/Android-%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80TagFlowLayout/"/>
    <url>/2022/07/25/Android-%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80TagFlowLayout/</url>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>这是一个Android流式布局，根据鸿翔大神之前写的<a href="https://github.com/hongyangAndroid/FlowLayout">FlowLayout</a>设计思路结合<code>Material</code>库中的<code>ChipGroup</code>设计架构衍生而来，全新的流式布局<a href="https://github.com/smallmarker/TagFlowLayout">TagFlowLayout</a>组件</strong></p><h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><p><img src="tagflowlayout_demo.gif" alt="tagflowlayout_demo"></p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="setter"><a href="#setter" class="headerlink" title="setter"></a>setter</h4><table><thead><tr><th align="center">方法名称</th><th align="center">作用</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center"><code>setTagSpacingHorizontal(@Dimension tagSpacingHorizontal: Int)</code></td><td align="center">Tag间的水平间距</td><td align="center"><code>setTagSpacingHorizontal(24)</code></td></tr><tr><td align="center"><code>setTagSpacingVertical(@Dimension tagSpacingVertical: Int)</code></td><td align="center">Tag间的垂直间距</td><td align="center"><code>setTagSpacingVertical(24)</code></td></tr><tr><td align="center"><code>setSingleLine(singleLine: Boolean)</code></td><td align="center">是否开启单行模式（默认false）</td><td align="center"><code>setSingleLine(true)</code></td></tr><tr><td align="center"><code>setSingleSelection(singleSelection: Boolean)</code></td><td align="center">是否开启单选模式（默认false）</td><td align="center"><code>setSingleSelection(true)</code></td></tr><tr><td align="center"><code>setSelectionRequired(selectionRequired: Boolean)</code></td><td align="center">是否为必选项（默认false</td><td align="center"><code>setSelectionRequired(true)</code></td></tr><tr><td align="center"><code>setSelectMax(selectMax: Int)</code></td><td align="center">最大选择数量（&lt;=0为无效值</td><td align="center"><code>setSelectMax(10)</code></td></tr><tr><td align="center"><code>setOnTagClickListener(tagClickListener: TagClickListener)</code></td><td align="center">设置Tag点击事件</td><td align="center"><code>setOnTagClickListener &#123; view, position, parent -&gt; &#125;</code></td></tr><tr><td align="center"><code>setCheckedChangedListener(checkedChangedListener: CheckedChangedListener)</code></td><td align="center">设置Tag状态变更监听事件</td><td align="center"><code>setCheckedChangedListener &#123; group, checkedIds -&gt; &#125;</code></td></tr></tbody></table><h4 id="getter"><a href="#getter" class="headerlink" title="getter"></a>getter</h4><table><thead><tr><th align="center">方法名称</th><th align="center">作用</th><th align="center">返回类型</th></tr></thead><tbody><tr><td align="center"><code>isSelectMax()</code></td><td align="center">是否达到最大的选择数量</td><td align="center"><code>Boolean</code></td></tr><tr><td align="center"><code>clearCheck()</code></td><td align="center">清除所有选中数据</td><td align="center"><code>void</code></td></tr><tr><td align="center"><code>getCheckedTagOrder()</code></td><td align="center">获取选中单选下标</td><td align="center"><code>Int</code></td></tr><tr><td align="center"><code>getCheckedTagOrders()</code></td><td align="center">获取选中集合下标组</td><td align="center"><code>List&lt;Int&gt;</code></td></tr></tbody></table><h4 id="Attributes属性"><a href="#Attributes属性" class="headerlink" title="Attributes属性"></a>Attributes属性</h4><table><thead><tr><th align="center">属性名称</th><th align="center">作用</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center"><code>app:tagSpacing</code></td><td align="center">Tag间的间距</td><td align="center"><code>app:tagSpacing=&quot;24dp&quot;</code></td></tr><tr><td align="center"><code>app:tagSpacingHorizontal</code></td><td align="center">Tag间的水平间距</td><td align="center"><code>app:tagSpacingHorizontal=&quot;24dp&quot;</code></td></tr><tr><td align="center"><code>app:tagSpacingVertical</code></td><td align="center">Tag间的垂直间距</td><td align="center"><code>app:tagSpacingVertical=&quot;24dp&quot;</code></td></tr><tr><td align="center"><code>app:singleLine</code></td><td align="center">是否开启单行模式（默认false）</td><td align="center"><code>app:singleLine=&quot;true&quot;</code></td></tr><tr><td align="center"><code>app:singleSelection</code></td><td align="center">是否开启单选模式（默认false）</td><td align="center"><code>app:是否开启单选模式=&quot;true&quot;</code></td></tr><tr><td align="center"><code>app:selectionRequired</code></td><td align="center">是否为必选项（默认false）</td><td align="center"><code>app:selectionRequired=&quot;true&quot;</code></td></tr><tr><td align="center"><code>app:selectMax</code></td><td align="center">最大选择数量（&lt;=0为无效值）</td><td align="center"><code>app:selectMax=&quot;10&quot;</code></td></tr></tbody></table><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">dependencies &#123;<br>    <span class="hljs-keyword">implementation</span> <span class="hljs-string">&#x27;io.github.smallmarker:tagflowlayout:1.0&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;com.smallmarker.tagflowlayout.TagFlowLayout<br>            android:<span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;@+id/tag_flow_layout&quot;</span><br>            android:<span class="hljs-attribute">layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span><br>            android:<span class="hljs-attribute">layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span><br>            app:<span class="hljs-attribute">tagSpacing</span>=<span class="hljs-string">&quot;16dp&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><h3 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h3><h4 id="方法属性"><a href="#方法属性" class="headerlink" title="方法属性"></a>方法属性</h4><ul><li>创建Adapter：<code>TagFlowAdapter.create(dataList)</code></li><li>设置Tag：<code>setView(parent: TagFlowLayout, position: Int, t: T)</code></li><li>设置Tag状态：<code>setChecked(position: Int, t: T)</code></li><li>监听状态变化：<code>setCheckedChanged(isChecked: Boolean, position: Int, view: View)</code></li><li>刷新适配器：<code>notifyDataSetChange()</code></li></ul><h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h4><ul><li><strong>设置数据</strong></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 设置Adapter</span><br>binding<span class="hljs-selector-class">.tagFlowLayout</span><span class="hljs-selector-class">.adapter</span> = TagFlowAdapter<span class="hljs-selector-class">.create</span>(dataList) &#123;<br>    setView &#123; parent, <span class="hljs-attribute">position</span>, t -&gt;<br>        <span class="hljs-built_in">TextView</span>(parent.context)<span class="hljs-selector-class">.apply</span> &#123;<br>            text = t<br>            <span class="hljs-built_in">setBackgroundResource</span>(R<span class="hljs-selector-class">.drawable</span>.bg_tag_selector)<br>            <span class="hljs-built_in">setPadding</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>选中状态</strong></li></ul><p>支持通过<code>state=checked</code>来控制选中和取消</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">selector</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">android:state_checked</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">shape</span> <span class="hljs-attr">android:shape</span>=<span class="hljs-string">&quot;rectangle&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">corners</span> <span class="hljs-attr">android:radius</span>=<span class="hljs-string">&quot;6dp&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">stroke</span> <span class="hljs-attr">android:width</span>=<span class="hljs-string">&quot;1.2dp&quot;</span> <span class="hljs-attr">android:color</span>=<span class="hljs-string">&quot;#374D9D&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">shape</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">shape</span> <span class="hljs-attr">android:shape</span>=<span class="hljs-string">&quot;rectangle&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">corners</span> <span class="hljs-attr">android:radius</span>=<span class="hljs-string">&quot;6dp&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">stroke</span> <span class="hljs-attr">android:width</span>=<span class="hljs-string">&quot;1.2dp&quot;</span> <span class="hljs-attr">android:color</span>=<span class="hljs-string">&quot;#C4C7D1&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">shape</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">selector</span>&gt;</span><br></code></pre></td></tr></table></figure><p>也可以自己在<code>Adapter</code> 的<code>setCheckedChanged</code>处理显示</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">setCheckedChanged &#123; isChecked, <span class="hljs-attribute">position</span>, view -&gt;<br>                Log<span class="hljs-selector-class">.d</span>(<span class="hljs-string">&quot;TAG&quot;</span>, <span class="hljs-string">&quot;当前TAG状态：$&#123;isChecked&#125;, $&#123;position&#125;&quot;</span>)<br>                view<span class="hljs-selector-class">.setBackgroundColor</span>(<span class="hljs-keyword">if</span> (isChecked) &#123;<br>                    Color<span class="hljs-selector-class">.RED</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    Color<span class="hljs-selector-class">.GRAY</span><br>                &#125;)<br>            &#125;<br></code></pre></td></tr></table></figure><ul><li><strong>事件</strong></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 点击事件</span><br>binding<span class="hljs-selector-class">.tagFlowLayout</span><span class="hljs-selector-class">.setOnTagClickListener</span> &#123; view, <span class="hljs-attribute">position</span>, parent -&gt;<br>    Log<span class="hljs-selector-class">.d</span>(<span class="hljs-string">&quot;TAG&quot;</span>, <span class="hljs-string">&quot;当前选中TAG： $&#123;position&#125;&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 状态监听</span><br>binding<span class="hljs-selector-class">.tagFlowLayout</span><span class="hljs-selector-class">.setCheckedChangedListener</span> &#123; group, checkedIds -&gt;<br>    binding<span class="hljs-selector-class">.tvTip</span><span class="hljs-selector-class">.text</span> = <span class="hljs-string">&quot;当前选中TAG序号：$&#123;checkedIds&#125;&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>偶然发现<code>material</code>库中<code>chip</code>组件，其通过<code>ChipGroup</code>实现流式布局的设计，加上很早之前有用过鸿神的<code>FlowLayout</code>库，所以就在此基础上写了一个新的流式布局组件，该组件在类的命名上还是沿用了鸿神之前的<code>FlowLayout</code>，为了不依赖<code>material</code>库的较高版本的限制，故将需要用到的类抽取使用，做兼容处理</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>Android 组件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android AGP升级后导致APK体积增大</title>
    <link href="/2022/06/10/Android-AGP%E5%8D%87%E7%BA%A7%E5%90%8E%E5%AF%BC%E8%87%B4APK%E4%BD%93%E7%A7%AF%E5%A2%9E%E5%A4%A7/"/>
    <url>/2022/06/10/Android-AGP%E5%8D%87%E7%BA%A7%E5%90%8E%E5%AF%BC%E8%87%B4APK%E4%BD%93%E7%A7%AF%E5%A2%9E%E5%A4%A7/</url>
    
    <content type="html"><![CDATA[<p><strong>项目AGP升级至7.0+后发现打出来release包的体积比之前增加近一倍，经过查询官方文档得知在AGP3.6.0时的行为变更上：默认情况下，原生库以未压缩的形式打包。</strong></p><p>在构建应用时，插件现在默认会将 <code>extractNativeLibs</code> 设置为<code> &quot;false&quot;</code>也就是说，您的原生库将保持页面对齐状态并以未压缩的形式打包。虽然这样会增加上传大小，但您的用户会从以下优势中受益：</p><ul><li>减小应用安装大小，因为平台可以直接从已安装的 APK 访问原生库，而无需创建库的副本。</li><li>减小下载文件大小，因为在 APK 或 <code>Android App Bundle</code> 中添加未压缩的原生库通常可提高 Play 商店的压缩率。</li></ul><p>如果您希望 <code>Android Gradle</code> 插件改为打包压缩后的原生库，请在应用的清单中添加以下代码：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-built_in">application</span><br>    android:extractNativeLibs=<span class="hljs-string">&quot;true&quot;</span><br>    ... &gt;<br>&lt;/<span class="hljs-built_in">application</span>&gt;<br></code></pre></td></tr></table></figure><p><strong>但是从 AGP 4.2.0 开始，<code>extractNativeLibs</code> 清单属性已被 DSL 选项 <code>useLegacyPackaging</code> 取代。 您应该使用应用的 <code>build.gradle</code> 文件中的 <code>useLegacyPackaging</code>（而非清单文件中的 <code>extractNativeLibs</code>）来配置原生库压缩行为：</strong></p><h5 id="使用-DSL-打包压缩后的原生库"><a href="#使用-DSL-打包压缩后的原生库" class="headerlink" title="使用 DSL 打包压缩后的原生库"></a>使用 DSL 打包压缩后的原生库</h5><p>官方建议以未压缩的形式打包原生库，因为这会减小应用安装大小，缩减应用下载大小，并缩短用户的应用加载时间。不过，如果您希望 <code>Android Gradle</code> 插件在构建应用时打包压缩后的原生库，请在应用的 <code>build.gradle</code> 文件中将 <code>useLegacyPackaging</code>设置为 <code>true</code>：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">android</span> &#123;<br>    <span class="hljs-keyword">packagingOptions</span> &#123;<br>        <span class="hljs-keyword">jniLibs</span> &#123;<br>            useLegacyPackaging <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：<code>useLegacyPackaging</code> 标记会替换 <code>extractNativeLibs</code> 清单属性。默认情况下，原生库以未压缩的形式打包。</strong></p><p>官方文档参考：</p><p><a href="https://developer.android.com/studio/releases/gradle-plugin?buildsystem=ndk-build#extractNativeLibs">https://developer.android.com/studio/releases/gradle-plugin?buildsystem=ndk-build#extractNativeLibs</a></p><p><a href="https://developer.android.com/studio/releases/gradle-plugin?buildsystem=ndk-build#compress-native-libs-dsl">https://developer.android.com/studio/releases/gradle-plugin?buildsystem=ndk-build#compress-native-libs-dsl</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Android 奇遇记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
