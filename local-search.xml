<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Android 文本识别：MLKIT + PreviewView</title>
    <link href="/2023/05/26/Android-%E6%96%87%E6%9C%AC%E8%AF%86%E5%88%AB%EF%BC%9AMLKIT-PreviewView/"/>
    <url>/2023/05/26/Android-%E6%96%87%E6%9C%AC%E8%AF%86%E5%88%AB%EF%BC%9AMLKIT-PreviewView/</url>
    
    <content type="html"><![CDATA[<p><img src="mlkit.jpeg" alt="mlkit"></p><p>随着移动设备的普及和摄像头的高像素化，利用相机进行文本识别成为了一种流行的方式。MLKit 是 Google 提供的一款机器学习工具包，其中包含了丰富的图像和语言处理功能，包括文本识别。PreviewView 是 Android Jetpack 的一部分，它提供了一个方便的预览相机图像的视图组件。结合 MLKit 和 PreviewView，我们可以轻松构建出一个功能强大的文本识别应用程序。</p><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>为了使用 MLKit 和 PreviewView，我们需要在项目的 <code>build.gradle</code> 文件中添加相应的依赖项。以下是所需的依赖项：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-comment">// camera</span><br><span class="hljs-keyword">def</span> camerax_version = <span class="hljs-string">&quot;1.2.1&quot;</span><br>implementation <span class="hljs-string">&quot;androidx.camera:camera-core:$&#123;camerax_version&#125;&quot;</span><br>implementation <span class="hljs-string">&quot;androidx.camera:camera-camera2:$&#123;camerax_version&#125;&quot;</span><br>implementation <span class="hljs-string">&quot;androidx.camera:camera-lifecycle:$&#123;camerax_version&#125;&quot;</span><br>implementation <span class="hljs-string">&quot;androidx.camera:camera-video:$&#123;camerax_version&#125;&quot;</span><br>implementation <span class="hljs-string">&quot;androidx.camera:camera-view:$&#123;camerax_version&#125;&quot;</span><br>implementation <span class="hljs-string">&quot;androidx.camera:camera-extensions:$&#123;camerax_version&#125;&quot;</span><br><br><span class="hljs-comment">// To recognize Chinese script</span><br>implementation <span class="hljs-string">&#x27;com.google.mlkit:text-recognition-chinese:16.0.0&#x27;</span><br></code></pre></td></tr></table></figure><p>以上依赖项包含了与相机操作和中文文本识别相关的库。</p><h2 id="XML-布局"><a href="#XML-布局" class="headerlink" title="XML 布局"></a>XML 布局</h2><p>在布局文件中，我们需要添加一个 PreviewView（相机预览视图），一个按钮用于开始/停止文本识别，以及一个用于显示识别结果的 TextView。以下是布局文件的示例代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;.MainActivity&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">androidx.camera.view.PreviewView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/pre_view&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;0dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">&quot;1&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/btn_operation&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;点击停止文本识别&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_marginHorizontal</span>=<span class="hljs-string">&quot;16dp&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/tv_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;0dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">&quot;1&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:padding</span>=<span class="hljs-string">&quot;6dp&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上述布局文件包含了一个垂直排列的 LinearLayout，其中包含了一个 PreviewView、一个按钮和一个用于显示识别结果的 TextView。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>在代码实现部分，首先检查相机权限</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">manifest</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.CAMERA&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">manifest</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在权限被授予时初始化相机，进行文本识别。我们设置按钮的点击事件监听器，根据当前相机的状态执行相应的操作。当按钮被点击时，我们会根据相机的状态开始或停止文本识别，默认处于识别状态中。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span></span>() &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> binding: ActivityMainBinding<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> cameraProvider: ProcessCameraProvider? = <span class="hljs-literal">null</span><br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        binding = ActivityMainBinding.inflate(layoutInflater)<br>        setContentView(binding.root)<br>        requestPermission()<br><br>        binding.btnOperation.setOnClickListener &#123;<br>            cameraProvider?.let &#123;<br>                binding.btnOperation.text = <span class="hljs-string">&quot;点击开始文本识别&quot;</span><br>                cameraProvider?.unbindAll()<br>                cameraProvider = <span class="hljs-literal">null</span><br>            &#125; ?: run &#123;<br>                binding.btnOperation.text = <span class="hljs-string">&quot;点击停止文本识别&quot;</span><br>                setupCamera()<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 其他方法和实现代码...</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>onCreate()</code> 方法中，我们设置了按钮的点击事件监听器。当按钮被点击时，我们根据当前的相机状态执行相应的操作。如果相机已经初始化并正在运行，我们会停止文本识别并释放相机资源。如果相机未初始化或已停止，我们将开始文本识别并设置相机。</p><p>接下来，我们实现了请求相机权限的方法 <code>requestPermission()</code>，并在 <code>onCreate()</code> 方法中调用它。在 <code>onRequestPermissionsResult()</code> 方法中，我们检查相机权限的授权结果。如果权限被授予，我们将调用 <code>setupCamera()</code> 方法初始化相机。如果权限被拒绝，我们将显示一个简短的提示消息。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 申请相机权限</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">requestPermission</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">if</span> (ContextCompat.checkSelfPermission(<span class="hljs-keyword">this</span>, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) &#123;<br>        ActivityCompat.requestPermissions(<span class="hljs-keyword">this</span>, arrayOf(Manifest.permission.CAMERA), CAMERA_PERMISSION_CODE)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        setupCamera()<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onRequestPermissionsResult</span><span class="hljs-params">(requestCode: <span class="hljs-type">Int</span>, permissions: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">out</span> <span class="hljs-type">String</span>&gt;, grantResults: <span class="hljs-type">IntArray</span>)</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults)<br>    <span class="hljs-keyword">if</span> (requestCode == CAMERA_PERMISSION_CODE) &#123;<br>        <span class="hljs-keyword">if</span> (grantResults.isNotEmpty() &amp;&amp; grantResults[<span class="hljs-number">0</span>] == PackageManager.PERMISSION_GRANTED) &#123;<br>            setupCamera()<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Toast.makeText(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;权限被拒绝&quot;</span>, Toast.LENGTH_SHORT).show()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>requestPermission()</code> 方法中，我们检查相机权限并请求授权。如果权限已被授予，我们将调用 <code>setupCamera()</code> 方法初始化相机。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 设置相机</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setupCamera</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> cameraProviderFuture = ProcessCameraProvider.getInstance(<span class="hljs-keyword">this</span>)<br>    cameraProviderFuture.addListener(&#123;<br>        <span class="hljs-keyword">val</span> cameraProvider = cameraProviderFuture.<span class="hljs-keyword">get</span>()<br>        bindPreview(cameraProvider)<br>    &#125;, ContextCompat.getMainExecutor(<span class="hljs-keyword">this</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>setupCamera()</code> 方法中，我们使用 ProcessCameraProvider 获取相机实例，并通过 <code>bindPreview()</code> 方法将相机与 PreviewView 绑定。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 绑定 preview</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bindPreview</span><span class="hljs-params">(cameraProvider: <span class="hljs-type">ProcessCameraProvider</span>)</span></span> &#123;<br>    <span class="hljs-keyword">this</span>.cameraProvider = cameraProvider<br>    <span class="hljs-keyword">val</span> preview = Preview.Builder().build()<br>    <span class="hljs-keyword">val</span> cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA<br>    preview.setSurfaceProvider(binding.preView.surfaceProvider<br><br>)<br>    <span class="hljs-keyword">val</span> analysis = ImageAnalysis.Builder()<br>        .setOutputImageFormat(ImageAnalysis.OUTPUT_IMAGE_FORMAT_YUV_420_888)<br>        .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)<br>        .build()<br>    analysis.setAnalyzer(Executors.newSingleThreadExecutor(), <span class="hljs-keyword">this</span>::analyzeImage)<br>    cameraProvider.bindToLifecycle(<span class="hljs-keyword">this</span>, cameraSelector, preview, analysis)<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>bindPreview()</code> 方法中，我们创建了一个 Preview 实例，并将其与默认后置摄像头绑定。然后，我们设置 PreviewView 的 SurfaceProvider，并创建一个 ImageAnalysis 实例用于图像分析。通过设置图像分析器的回调方法，我们可以在每帧图像上执行文本识别。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 解析文本</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@SuppressLint(<span class="hljs-string">&quot;UnsafeOptInUsageError&quot;</span>)</span><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">analyzeImage</span><span class="hljs-params">(imageProxy: <span class="hljs-type">ImageProxy</span>)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> image = imageProxy.image ?: <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">val</span> inputImage = InputImage.fromMediaImage(image, imageProxy.imageInfo.rotationDegrees)<br>    <span class="hljs-keyword">val</span> recognizer = TextRecognition.getClient(ChineseTextRecognizerOptions.Builder().build())<br>    recognizer.process(inputImage)<br>        .addOnSuccessListener &#123; result -&gt;<br>            binding.tvContent.text = result.text<br>        &#125;<br>        .addOnCompleteListener &#123;<br>            <span class="hljs-comment">// 释放ImageProxy对象 </span><br>            imageProxy.close()<br>        &#125;<br>        .addOnFailureListener &#123;<br>            <span class="hljs-comment">// 处理识别过程中的错误</span><br>            it.printStackTrace()<br>            imageProxy.close()<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过实现了 <code>analyzeImage()</code> 方法，用于分析图像并执行文本识别。在该方法中，我们首先将 ImageProxy 转换为 InputImage，然后创建一个中文文本识别器。接下来，我们使用识别器对图像进行处理，并在成功完成时更新 TextView 的内容。无论成功与否，最后都会关闭 ImageProxy。这里如果我们想识别图片（Bitmap）中的文字可以调用 <code>InputImage.fromBitmap</code> 方法即可。</p><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>Ok，到这里我们文本识别的功能 demo 就实现了， 看看效果吧：</p><p><img src="textreconition.gif" alt="demo"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过结合 MLKit 和 PreviewView，我们可以轻松实现 Android 应用程序中的文本识别功能。在本篇文章中，我们详细讲解了如何使用 MLKit 和 PreviewView 实现文本识别。感兴趣的小伙伴可参考 Demo 地址：<a href="https://github.com/smallmarker/TextRecognition">TextRecognition</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Android 组件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android Jetpack - Navigation 组件：进行应用程序导航</title>
    <link href="/2023/04/22/Android-Jetpack-Navigation-%E7%BB%84%E4%BB%B6%EF%BC%9A%E8%BF%9B%E8%A1%8C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%AF%BC%E8%88%AA/"/>
    <url>/2023/04/22/Android-Jetpack-Navigation-%E7%BB%84%E4%BB%B6%EF%BC%9A%E8%BF%9B%E8%A1%8C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%AF%BC%E8%88%AA/</url>
    
    <content type="html"><![CDATA[<p><img src="jetpack-navigation-component.png" alt="jetpack-navigation-component"></p><h3 id="一-Navigation-组件的介绍"><a href="#一-Navigation-组件的介绍" class="headerlink" title="一. Navigation 组件的介绍"></a>一. Navigation 组件的介绍</h3><p>1.1 什么是 Navigation 组件</p><ul><li>Navigation 组件是一种 Android Jetpack 库，它可以帮助开发者轻松地实现应用程序中的导航功能。导航组件包含多个类和组件，包括导航图、目的地、导航控制器等，可以帮助我们管理应用程序中的页面导航和任务导航。通过使用 Navigation 组件，我们可以更加方便地实现应用程序的导航功能，同时也可以提高应用程序的用户体验。在本篇文章中，我们将介绍如何使用 Navigation 组件来实现应用程序导航，并提供一些示例和更多的扩展功能。</li></ul><p>1.2 Navigation 组件的优势</p><ul><li>Navigation 组件可以轻松实现应用程序中的导航，包括页面之间的转换和应用程序内部的导航。</li><li>Navigation 组件可以提高应用程序的可维护性和可扩展性，因为它们使得应用程序的结构更加清晰，并且可以更容易地添加新的功能和页面。</li><li>Navigation 组件可以提供一致的用户体验，因为它们使用了标准的导航模式和动画效果。</li><li>Navigation 组件可以帮助开发人员更快地构建应用程序，因为它们提供了许多常见的导航模式和功能，可以直接使用或进行修改。</li><li>Navigation 组件可以提高应用程序的可测试性，因为它们使得页面之间的导航和状态转换更加明确和可控。</li></ul><p>1.3 Navigation 组件主要由3个部分组成：</p><ul><li>NavHost：用来嵌入导航流程的容器,一般使用<code>FragmentContainerView</code>。</li><li>NavController：负责在<code>NavHost</code>内部处理导航事务的控制器，用于执行页面跳转、管理返回栈等。</li><li>NavGraph：描述<code>Fragment</code>之间导航关系的资源文件，在其中定义页面之间的转跳、动画等。一般放在<code>res/navigation/</code>目录下。</li></ul><p>简而言之，<code>Navigation</code>组件通过在<code>NavHost</code>中使用<code>NavGraph</code>来描述<code>Fragment</code>导航路径与关系，然后由<code>NavController</code>来执行实际的导航工作，这样极大地简化了以往的页面跳转逻辑和回退栈管理流程。 </p><h3 id="二-Navigation-组件的基本使用"><a href="#二-Navigation-组件的基本使用" class="headerlink" title="二. Navigation 组件的基本使用"></a>二. Navigation 组件的基本使用</h3><p>2.1 添加导航组件到项目中</p><ul><li>在项目的 build.gradle 文件中添加以下依赖：</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">dependencies</span> &#123;<br>    <span class="hljs-keyword">def</span> nav_version = <span class="hljs-string">&quot;2.5.3&quot;</span><br>    implementation <span class="hljs-string">&quot;androidx.navigation:navigation-fragment-ktx:$nav_version&quot;</span><br>    implementation <span class="hljs-string">&quot;androidx.navigation:navigation-ui-ktx:$nav_version&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在布局文件中添加 NavHostFragment：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">androidx.fragment.app.FragmentContainerView</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/nav_host_fragment&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;androidx.navigation.fragment.NavHostFragment&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">app:navGraph</span>=<span class="hljs-string">&quot;@navigation/nav_graph&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><ul><li>正确获取 NavController 对象 ：</li></ul><p>在 Activity 内使用 NavController 时,应在<code>onCreate()</code>中获取:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> navHostFragment = supportFragmentManager.findFragmentById(R.id.nav_host_fragment) <span class="hljs-keyword">as</span> NavHostFragment<br><span class="hljs-keyword">val</span> navController = navHostFragment.navController<br>NavigationUI.setupActionBarWithNavController(<span class="hljs-keyword">this</span>, navController)<br></code></pre></td></tr></table></figure><p>而在 Fragment 内,应在<code>onAttach()</code>或<code>onViewCreate()</code>中获取:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> navHostFragment = parentFragment <span class="hljs-keyword">as</span> NavHostFragment<br><span class="hljs-keyword">val</span> navController = navHostFragment.navController<br></code></pre></td></tr></table></figure><p><code>NavHost</code>需要指定<code>app:navGraph</code>属性来关联一个导航图<code>NavGraph</code>，这决定了其中<code>Fragment</code>页面之间的导航关系和跳转路径。</p><p><code>NavController</code>是 <code>Navigation</code>组件的控制中心，用于在<code>NavHost</code>内执行导航操作。可以在<code>Activity</code>或<code>Fragment</code>中通过<code>NavHostFragment</code>的<code>navController</code>属性获取对应的<code>NavController</code>实例。</p><p>常见的导航操作有:</p><ul><li>导航到目标目的地：<code>navController.navigate(R.id.destination_id)</code></li><li>回退一个目的地：<code>navController.navigateUp()</code> 或 <code>navController.popBackStack()</code></li><li>回退到根目的地：<code>navController.popBackStack(R.id.root_destination, false)</code></li></ul><p><code>NavController</code>还负责维护<code>Fragment</code>的回退栈，以及在按返回按钮时正确出栈，这大大简化了之前管理<code>Fragment</code>事务的复杂度。<br>通过<code>NavHost</code>和<code>NavController</code>的配合，<code>Navigation</code>组件实现了在<code>NavGraph</code>中声明的导航逻辑和页面切换功能。这使<code>Fragment</code>之间的导航变得极为简单高效。开发者只需关注于定义<code>NavGraph</code>，并调用<code>NavController</code>中的导航方法即可实现页面跳转,其余的一切尽在<code>Navigation</code>组件的掌控之中。 </p><p>2.2 创建导航图</p><ul><li><p>在XML文件中创建导航图：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">androidx.fragment.app.FragmentContainerView</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/nav_host_fragment&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;androidx.navigation.fragment.NavHostFragment&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">app:navGraph</span>=<span class="hljs-string">&quot;@navigation/nav_graph&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在res文件夹下创建一个<code>navigation</code>文件夹，然后在该文件夹下创建一个<code>nav_graph.xml</code>文件，用于定义导航图的结构和内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">navigation</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/nav_graph&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">app:startDestination</span>=<span class="hljs-string">&quot;@id/firstFragment&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">fragment</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/firstFragment&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.smallmarker.jetpackpractice.navigation.fragment.FirstFragment&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:label</span>=<span class="hljs-string">&quot;First&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">tools:layout</span>=<span class="hljs-string">&quot;@layout/fragment_first&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/action_firstFragment_to_secondFragment&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">app:destination</span>=<span class="hljs-string">&quot;@+id/secondFragment&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">fragment</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">fragment</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/secondFragment&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.smallmarker.jetpackpractice.navigation.fragment.SecondFragment&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:label</span>=<span class="hljs-string">&quot;Second&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">tools:layout</span>=<span class="hljs-string">&quot;@layout/fragment_second&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">navigation</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p>在导航图中，<code>&lt;fragment&gt;</code> 元素用于定义目的地，<code>android:id</code>属性用于指定目的地的唯一标识符，<code>android:name</code> 属性用于指定目的地的类名，<code>android:label</code> 属性用于指定目的地在应用程序中显示的标签名称。</p><p><code>&lt;action&gt;</code> 元素用于定义动作，<code>android:id</code> 属性用于指定动作的唯一标识符，<code>app:destination</code> 属性用于指定动作要执行的目的地。</p><h3 id="三-Navigation-组件的高级使用"><a href="#三-Navigation-组件的高级使用" class="headerlink" title="三. Navigation 组件的高级使用"></a>三. Navigation 组件的高级使用</h3><p>3.1 深层链接</p><p>在 Android 中，深层链接是指将用户直接转到应用内特定目的地的链接。借助 Navigation 组件，您可以创建两种不同类型的深层链接：显式深层链接和隐式深层链接。</p><ul><li>创建显式深层链接：</li></ul><p>显式深层链接是深层链接的一个实例，该实例使用 <code>PendingIntent</code> 将用户转到应用内的特定位置。例如，您可以在通知或应用 <code>widget</code> 中显示显式深层链接。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> pendingIntent = NavDeepLinkBuilder(it)<br>    .setGraph(R.navigation.nav_deep_link)<br>    .setDestination(R.id.deepLinkFragment)<br>    .setArguments(<br>        Bundle().apply &#123;<br>            putInt(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-number">1</span>)<br>        &#125;<br>    )<br>    .setComponentName(DeepLinkActivity::<span class="hljs-keyword">class</span>.java)<br>    .createPendingIntent()<br><br><span class="hljs-keyword">val</span> notification = NotificationCompat.Builder(it, <span class="hljs-string">&quot;my_channel&quot;</span>)<br>    .setContentTitle(<span class="hljs-string">&quot;Title&quot;</span>)<br>    .setContentText(<span class="hljs-string">&quot;测试深层链接&quot;</span>)<br>    .setSmallIcon(R.mipmap.ic_launcher)<br>    .setContentIntent(pendingIntent)<br>    .build()<br><br>NotificationManagerCompat.from(it).notify(Random.nextInt(<span class="hljs-number">10</span>), notification)<br></code></pre></td></tr></table></figure><p>该示例使用 <code>NavDeepLinkBuilder</code> 类构造 <code>PendingIntent</code>, 添加到通知中并发送，点击通知跳转指定页面。</p><ul><li>创建隐式深层链接：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">navigation</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/nav_deep_link&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">app:startDestination</span>=<span class="hljs-string">&quot;@id/deepLinkFragment&quot;</span>&gt;</span><br>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">fragment</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/deepLinkFragment&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.smallmarker.jetpackpractice.navigation.fragment.DeepLinkFragment&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:label</span>=<span class="hljs-string">&quot;DeepLink&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">tools:layout</span>=<span class="hljs-string">&quot;@layout/fragment_deep_link&quot;</span>&gt;</span><br>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">deepLink</span> <span class="hljs-attr">app:uri</span>=<span class="hljs-string">&quot;example://deepLink/&#123;id&#125;&quot;</span> /&gt;</span><br>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">fragment</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">navigation</span>&gt;</span><br></code></pre></td></tr></table></figure><p>  如需启用隐式深层链接，您还必须向应用的 <code>manifest.xml</code> 文件中添加内容。将一个 <code>&lt;nav-graph&gt;</code> 元素添加到指向现有导航图的 <code>activity</code>，如以下示例所示。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.navigation.DeepLinkActivity&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">nav-graph</span> <span class="hljs-attr">android:value</span>=<span class="hljs-string">&quot;@navigation/nav_deep_link&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span><br></code></pre></td></tr></table></figure><p>  在这个例子中，我们定义了一个深度链接，它的 URI 是<code>&quot;example://deepLink/&#123;id&#125;&quot;</code>，其中<code>&#123;itemId&#125;</code>是一个参数。当用户在浏览器或其他应用中点击这个链接时，Android 系统会自动打开我们的应用，并跳转到对应的页面，同时将参数传递给我们的应用。我们可以在目标页面中通过<code>arguments</code>来获取这个参数。</p><p>3.2 共享元素转场</p><ul><li>共享元素转场可以实现在不同<code>Activity</code>或<code>Fragment</code>之间共享相同元素的动画效果，比如在列表页面点击某个<code>item</code>进入详情页面时，可以让这个<code>item</code>的图片或文字在两个页面之间平滑地过渡。以下是一个简单的实现示例：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 在layout文件中定义共享元素的id --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span> </span><br><span class="hljs-tag">  <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/image_view&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">android:transitionName</span>=<span class="hljs-string">&quot;shared_element&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><ul><li>到 Fragment 目的地的共享元素过渡</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> extras = FragmentNavigatorExtras(view1 to <span class="hljs-string">&quot;shared_element&quot;</span>)<br><br>view.findNavController().navigate(R.id.confirmationAction, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, extras)<br></code></pre></td></tr></table></figure><ul><li>到 Activity 目的地的共享元素过渡</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> option = ActivityOptionsCompat.makeSceneTransitionAnimation(activity, imageView, <span class="hljs-string">&quot;shared_element&quot;</span>)<br>findNavController().navigate(R.id.shareElementDialog, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, ActivityNavigatorExtras(option))<br></code></pre></td></tr></table></figure><p>  共享元素以程序化方式提供，而不是通过导航 XML 文件提供。<code>activity</code> 和 <code>fragment</code> 目的地各自都有 <code>Navigator.Extras</code> 接口的一个子类，它接受导航的附加选项，包括共享元素。您可以在调用 <code>navigate()</code> 时传递这些 <code>Extras</code>。</p><p>3.3 导航图的动态构建- 动态构建导航图可以在运行时根据不同的条件创建不同的导航图，例如用户登录状态不同、权限不同等情况下展示不同的导航结构。</p><ul><li>下面是一个简单的动态构建导航图的示例：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> navHostFragment = supportFragmentManager.findFragmentById(R.id.nav_host_fragment) <span class="hljs-keyword">as</span> NavHostFragment<br><span class="hljs-keyword">val</span> navController = navHostFragment.navController<br><span class="hljs-keyword">val</span> graph = navInflater.inflate(R.navigation.dynamic_nav_graph)<br><br><span class="hljs-keyword">if</span> (isLoggedIn) &#123;<br>    graph.startDestination = R.id.homeFragment<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    graph.startDestination = R.id.loginFragment<br>&#125;<br><br><span class="hljs-keyword">if</span> (hasAdminPermissions) &#123;<br>    <span class="hljs-keyword">val</span> adminNode = NavGraphNavigator(navController.navigatorProvider.getNavigator(NavGraphNavigator::<span class="hljs-keyword">class</span>.java))<br>        .createDestination()<br>    adminNode.id = R.id.adminFragment<br>    adminNode.setClassName(<span class="hljs-string">&quot;com.example.app.AdminFragment&quot;</span>)<br>    graph.addDestination(adminNode)<br>    graph.addEdge(R.id.homeFragment, R.id.adminFragment)<br>&#125;<br><br>navController.graph = graph<br></code></pre></td></tr></table></figure><p>  在上面的示例中，我们首先获取到了当前的<code>NavController</code>和<code>NavInflater</code>，然后通过<code>NavInflater.inflate</code>方法来加载我们的动态导航图。接着，我们根据不同的条件设置了导航图的起始目的地，并且在有管理员权限的情况下动态添加了一个目的地，并且添加了一条边来连接这个目的地和主页。最后，我们将构建好的导航图设置到<code>NavController</code>中即可。</p><h3 id="四-导航组件的最佳实践"><a href="#四-导航组件的最佳实践" class="headerlink" title="四. 导航组件的最佳实践"></a>四. 导航组件的最佳实践</h3><p>4.1 使用<code>&lt;include&gt;</code>标签</p><ul><li>为每个模块定义单独的<code>NavGraph</code>在大型项目中,最好为每个功能模块定义自己的<code>NavGraph</code>,然后在根<code>NavGraph</code>中使用<code>&lt;include&gt;</code>标签将每个模块的<code>NavGraph</code>组合起来:：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">navigation</span> </span><br><span class="hljs-tag">  <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/root_navigation&quot;</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">include</span> </span><br><span class="hljs-tag">      <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/home_navigation&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">app:layout</span>=<span class="hljs-string">&quot;@navigation/home_navigation&quot;</span> /&gt;</span><br>      <br>  <span class="hljs-tag">&lt;<span class="hljs-name">include</span> </span><br><span class="hljs-tag">      <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/profile_navigation&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">app:layout</span>=<span class="hljs-string">&quot;@navigation/profile_navigation&quot;</span> /&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">navigation</span>&gt;</span><br></code></pre></td></tr></table></figure><p>4.1 使用 ViewModel 和 LiveData</p><ul><li>在 ViewModel 中使用 LiveData 对象来处理导航事件：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainViewModel</span> : <span class="hljs-type">ViewModel</span></span>() &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> navigateTo = MutableLiveData&lt;NavDirections&gt;()<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getNavigateTo</span><span class="hljs-params">()</span></span>: LiveData&lt;NavDirections&gt; &#123;<br>        <span class="hljs-keyword">return</span> navigateTo<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setNavigateTo</span><span class="hljs-params">(directions: <span class="hljs-type">NavDirections</span>)</span></span> &#123;<br>        navigateTo.value = directions<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在 Fragment 中观察 LiveData 对象并处理导航事件：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainFragment</span> : <span class="hljs-type">Fragment</span></span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        viewModel.getNavigateTo().observe(<span class="hljs-keyword">this</span>) &#123;<br>            Navigation.findNavController(requireView()).navigate(it)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">clickJump</span><span class="hljs-params">()</span></span> &#123;<br>        viewModel.setNavigateTo(MainFragmentDirections.actionMainToNavigationActivity())<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里我们使用了 <code>Safe Args</code> 实现类型安全的导航，在目的地之间导航，官方也是建议使用 <code>Safe Args Gradle</code> 插件。此插件可生成简单的对象和构建器类，以便在目的地之间实现类型安全的导航。我们强烈建议您在导航以及在目的地之间传递数据时使用 <code>Safe Args</code>。<br>如需将 <code>Safe Args</code> 添加到您的项目，请在顶层 <code>build.gradle</code> 文件中包含以下 <code>classpath：</code></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">buildscript</span> &#123;<br>    <span class="hljs-keyword">dependencies</span> &#123;<br>        <span class="hljs-keyword">def</span> nav_version = <span class="hljs-string">&quot;2.5.3&quot;</span><br>        <span class="hljs-keyword">classpath</span>(<span class="hljs-string">&quot;androidx.navigation:navigation-safe-args-gradle-plugin:$nav_version&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后再将以下行添加到应用或模块的 build.gradle 文件中：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">plugins &#123;<br>    id(<span class="hljs-string">&quot;androidx.navigation.safeargs.kotlin&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="五-总结"><a href="#五-总结" class="headerlink" title="五. 总结"></a>五. 总结</h3><p>5.1 导航组件的优势和适用场景：</p><table><thead><tr><th>优势</th><th>适用场景</th></tr></thead><tbody><tr><td>1. 提供一致的导航体验</td><td>适用于需要在应用中引入多个页面的场景</td></tr><tr><td>2. 简化导航逻辑</td><td>适用于需要在应用中进行复杂的导航操作的场景</td></tr><tr><td>3. 可自定义外观和行为</td><td>适用于需要根据应用需求自定义导航栏的场景</td></tr><tr><td>4. 支持深层链接</td><td>适用于需要在应用中支持深层链接的场景</td></tr><tr><td></td><td></td></tr></tbody></table><p>5.2 导航组件的最佳实践- 在使用导航组件时，应该尽量减少手动操作 Fragment 事务，而是使用导航组件提供的 API 进行操作，以避免出现不必要的错误。</p><ul><li>在设计导航图时，应该尽量将功能相似的页面放在同一个导航图中，以便于管理和维护。</li><li>在使用 Safe Args 插件传递参数时，应该尽量使用安全的类型，以避免出现类型转换错误。</li></ul><p><strong>以上就是对 Android Navigation 的探索与实践的过程，上述示例 + 扩展（结合 BottomNavigationView 和 DrawerLayout）请参考 <a href="https://github.com/smallmarker/JetPackPractice">https://github.com/smallmarker/JetPackPractice</a></strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>JetPack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter GetX 实现 ChatGPT 简单聊天界面</title>
    <link href="/2023/03/24/Flutter-GetX-%E5%AE%9E%E7%8E%B0-ChatGPT-%E7%AE%80%E5%8D%95%E8%81%8A%E5%A4%A9%E7%95%8C%E9%9D%A2/"/>
    <url>/2023/03/24/Flutter-GetX-%E5%AE%9E%E7%8E%B0-ChatGPT-%E7%AE%80%E5%8D%95%E8%81%8A%E5%A4%A9%E7%95%8C%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<p><strong>Flutter 是一款跨平台的移动应用开发框架，而 GetX 是 Flutter 中一种简单易用的状态管理和路由管理工具。本篇我们将使用 Flutter 和 GetX 实现一个简单的聊天界面，以与 ChatGPT 进行交互。</strong></p><p>我们需要在 Flutter 项目中引入 GetX 库。在<code>pubspec.yaml</code>文件中添加以下依赖：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">dependencies:</span><br><span class="hljs-symbol">  flutter:</span><br><span class="hljs-symbol">    sdk:</span> flutter<br><span class="hljs-symbol">  get:</span> <br><br></code></pre></td></tr></table></figure><p>在<code>main</code>函数中添加以下代码：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">void <span class="hljs-selector-tag">main</span>() &#123;<br>  <span class="hljs-comment">//在main函数第一行添加这句话</span><br>  WidgetsFlutterBinding<span class="hljs-selector-class">.ensureInitialized</span>();<br>  <span class="hljs-built_in">runApp</span>(GetMaterialApp(<br>    home: ChatPage(),<br>  ));<br>&#125;<br></code></pre></td></tr></table></figure><p>确保<code>Flutter Widgets</code>已经初始化，并且启动应用程序的<code>ChatPage</code>页面。</p><p>接下来，我们需要创建一个<code>ApiProvider</code>类，用于与 OpenAI API 进行交互。这个类继承自<code>GetConnect</code>，<code>GetConnect</code>是一个轻量级的 HTTP 客户端，它能够简化与 API 的通信过程。以下是<code>ApiProvider</code>类的代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">GetConnect</span> </span>&#123;<br><br>  <span class="hljs-comment">/// <span class="language-markdown">这里填写自己OpenAI API Key</span></span><br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> apiKey = <span class="hljs-string">&#x27;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&#x27;</span>;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">String</span> baseUrl = <span class="hljs-string">&#x27;https://api.openai.com&#x27;</span>;<br>  <span class="hljs-keyword">final</span> <span class="hljs-built_in">Duration</span> timeout = <span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">30</span>);<br><br>  <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>&gt; _headers() &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>,<br>      <span class="hljs-string">&#x27;Authorization&#x27;</span>: <span class="hljs-string">&#x27;Bearer <span class="hljs-subst">$apiKey</span>&#x27;</span>,<br>    &#125;;<br>  &#125;<br><br>  ApiProvider() &#123;<br>    httpClient.baseUrl = baseUrl;<br>    httpClient.timeout = timeout;<br>    httpClient.addAuthenticator((request)  &#123;<br>      request.headers.addAll(_headers());<br>      <span class="hljs-keyword">return</span> request;<br>    &#125;);<br>  &#125;<br><br>  Future&lt;Response&gt; completions(<span class="hljs-built_in">String</span> body) &#123;<br>    <span class="hljs-keyword">return</span> post(<span class="hljs-string">&#x27;/v1/chat/completions&#x27;</span>, body);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个类中，我们设置了 API 的基础 URL 和超时时间，并实现了 HTTP 请求的授权和身份验证。我们还实现了<code>completions</code>方法，用于向 OpenAI API 发送请求并获取聊天机器人的回复。注意这里需要设置自己账号的API KEY， 地址： <a href="https://platform.openai.com/account/api-keys">https://platform.openai.com/account/api-keys</a></p><p>接下来，我们需要创建一个<code>ChatLogic</code>类，用于处理聊天机器人的逻辑。以下是<code>ChatLogic类</code>的代码：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs pf">class ChatLogic extends GetxController &#123;<br>  final ChatState <span class="hljs-keyword">state</span> = ChatState();<br>  final ApiProvider provider = ApiProvider();<br><br>  Future<span class="hljs-variable">&lt;void&gt;</span> sendMessage(String content) async &#123;<br>    <span class="hljs-keyword">state</span>.requestStatus(content);<br>    update();<br>    final response = await provider.completions(json.encode(&#123;<br>      <span class="hljs-string">&quot;model&quot;</span>: <span class="hljs-string">&quot;gpt-3.5-turbo&quot;</span>,<br>      <span class="hljs-string">&quot;messages&quot;</span>: [&#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;$content&quot;</span>&#125;]<br>    &#125;));<br>    try &#123;<br>      if(response.statusCode == <span class="hljs-number">200</span>) &#123;<br>        final data = response.body;<br>        final text = data[&#x27;choices&#x27;][<span class="hljs-number">0</span>][&#x27;message&#x27;][&#x27;content&#x27;];<br>        <span class="hljs-keyword">state</span>.responseStatus(text);<br>      &#125; else &#123;<br>        <span class="hljs-keyword">state</span>.responseStatus(response.statusText ?? &#x27;请求错误，请稍后重试&#x27;);<br>      &#125;<br>    &#125; catch(error) &#123;<br>      <span class="hljs-keyword">state</span>.responseStatus(error.<span class="hljs-keyword">to</span>String());<br>    &#125;<br>    update();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个类中，我们创建了一个<code>sendMessage</code>方法，该方法接收用户的消息并发送给 OpenAI API，然后等待 API 返回响应。在收到响应后，我们将从 API 返回的 JSON 数据中提取出回复消息的内容，并将其更新到<code>ChatState</code>状态类的<code>messages</code>列表中，然后在 UI 中显示。</p><p>接下来，我们需要创建一个<code>ChatState</code>类来管理我们的应用程序状态。以下是<code>ChatState</code>类的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChatState</span> &#123;<br><br>  <span class="hljs-title class_">String</span> message = <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-title class_">String</span> sender = <span class="hljs-string">&#x27;user&#x27;</span>;<br>  bool isRequesting = <span class="hljs-literal">false</span>;<br>  <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, dynamic&gt;&gt; messages = [];<br><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">requestStatus</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> content</span>) &#123;<br>    messages.<span class="hljs-title function_">add</span>(&#123;<span class="hljs-string">&#x27;text&#x27;</span>: content, <span class="hljs-string">&#x27;sender&#x27;</span>: <span class="hljs-string">&#x27;user&#x27;</span>&#125;);<br>    sender = <span class="hljs-string">&#x27;bot&#x27;</span>;<br>    messages.<span class="hljs-title function_">add</span>(&#123;<span class="hljs-string">&#x27;text&#x27;</span>: <span class="hljs-string">&#x27;正在回复中...&#x27;</span>, <span class="hljs-string">&#x27;sender&#x27;</span>: sender&#125;);<br>    isRequesting = <span class="hljs-literal">true</span>;<br>    message = <span class="hljs-string">&#x27;&#x27;</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">responseStatus</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> content</span>) &#123;<br>    messages.<span class="hljs-title function_">removeLast</span>(); <span class="hljs-comment">// Remove &quot;正在回复中...&quot; 状态</span><br>    messages.<span class="hljs-title function_">add</span>(&#123;<span class="hljs-string">&#x27;text&#x27;</span>: content, <span class="hljs-string">&#x27;sender&#x27;</span>: sender&#125;);<br>    sender = <span class="hljs-string">&#x27;user&#x27;</span>;<br>    isRequesting = <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个类中，存储了聊天应用程序的状态信息，包括消息、发送者、请求状态和历史消息列表。<code>requestStatus()</code>方法用于更新状态以反映正在发送消息的状态，<code>responseStatus()</code>方法用于更新状态以反映接收到的消息。</p><p>最后，我们定义了<code>ChatPage</code>类，它继承自<code>StatelessWidget</code>，它将用于展示聊天对话框。以下是<code>ChatPage</code>类的代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChatPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;<br>  <span class="hljs-title function_ invoke__">ChatPage</span>(&#123;Key? key&#125;) : <span class="hljs-title function_ invoke__">super</span>(<span class="hljs-attr">key</span>: key);<br><br>  <span class="hljs-keyword">final</span> logic = Get.<span class="hljs-title function_ invoke__">put</span>(<span class="hljs-title function_ invoke__">ChatLogic</span>());<br>  <span class="hljs-keyword">final</span> state = Get.find&lt;ChatLogic&gt;().state;<br><br>  @override<br>  Widget <span class="hljs-title function_ invoke__">build</span>(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Scaffold</span>(<br>      <span class="hljs-attr">appBar</span>: <span class="hljs-title function_ invoke__">AppBar</span>(<br>        <span class="hljs-attr">centerTitle</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">title</span>: <span class="hljs-title function_ invoke__">Text</span>(<span class="hljs-string">&#x27;你问我答&#x27;</span>),<br>      ),<br>      <span class="hljs-attr">body</span>: GetBuilder&lt;ChatLogic&gt;(<br>        <span class="hljs-attr">builder</span>: (context) =&gt; <span class="hljs-title function_ invoke__">Column</span>(<br>          <span class="hljs-attr">children</span>: [<br>            <span class="hljs-title function_ invoke__">Expanded</span>(<br>              <span class="hljs-attr">child</span>: ListView.<span class="hljs-title function_ invoke__">builder</span>(<br>                <span class="hljs-attr">itemCount</span>: state.messages.length,<br>                <span class="hljs-attr">itemBuilder</span>: (BuildContext context, <span class="hljs-keyword">int</span> index) &#123;<br>                  Map m = state.messages[index];<br>                  <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Padding</span>(<br>                    <span class="hljs-attr">padding</span>: <span class="hljs-keyword">const</span> EdgeInsets.<span class="hljs-title function_ invoke__">all</span>(<span class="hljs-number">8.0</span>),<br>                    <span class="hljs-attr">child</span>: <span class="hljs-title function_ invoke__">Row</span>(<br>                      <span class="hljs-attr">mainAxisAlignment</span>: m[<span class="hljs-string">&#x27;sender&#x27;</span>] == <span class="hljs-string">&#x27;user&#x27;</span><br>                          ? MainAxisAlignment.end<br>                          : MainAxisAlignment.start,<br>                      <span class="hljs-attr">children</span>: [<br>                        <span class="hljs-title function_ invoke__">Flexible</span>(<br>                          <span class="hljs-attr">child</span>: <span class="hljs-title function_ invoke__">Container</span>(<br>                            <span class="hljs-attr">padding</span>: <span class="hljs-keyword">const</span> EdgeInsets.<span class="hljs-title function_ invoke__">all</span>(<span class="hljs-number">8.0</span>),<br>                            <span class="hljs-attr">decoration</span>: <span class="hljs-title function_ invoke__">BoxDecoration</span>(<br>                              <span class="hljs-attr">borderRadius</span>: BorderRadius.<span class="hljs-title function_ invoke__">circular</span>(<span class="hljs-number">8.0</span>),<br>                              <span class="hljs-attr">color</span>: m[<span class="hljs-string">&#x27;sender&#x27;</span>] == <span class="hljs-string">&#x27;user&#x27;</span><br>                                  ? Colors.green[<span class="hljs-number">100</span>]<br>                                  : Colors.white,<br>                            ),<br>                            <span class="hljs-attr">child</span>: <span class="hljs-title function_ invoke__">Text</span>(m[<span class="hljs-string">&#x27;text&#x27;</span>]),<br>                          ),<br>                        )<br>                      ],<br>                    ),<br>                  );<br>                &#125;,<br>              ),<br>            ),<br>            <span class="hljs-title function_ invoke__">Container</span>(<br>              <span class="hljs-attr">decoration</span>: <span class="hljs-title function_ invoke__">BoxDecoration</span>(<br>                <span class="hljs-attr">color</span>: Colors.white,<br>                <span class="hljs-attr">borderRadius</span>: BorderRadius.<span class="hljs-title function_ invoke__">only</span>(<br>                  <span class="hljs-attr">topLeft</span>: Radius.<span class="hljs-title function_ invoke__">circular</span>(<span class="hljs-number">12.0</span>),<br>                  <span class="hljs-attr">topRight</span>: Radius.<span class="hljs-title function_ invoke__">circular</span>(<span class="hljs-number">12.0</span>),<br>                ),<br>              ),<br>              <span class="hljs-attr">child</span>: <span class="hljs-title function_ invoke__">Row</span>(<br>                <span class="hljs-attr">children</span>: [<br>                  <span class="hljs-title function_ invoke__">Expanded</span>(<br>                    <span class="hljs-attr">child</span>: <span class="hljs-title function_ invoke__">Padding</span>(<br>                      <span class="hljs-attr">padding</span>: <span class="hljs-keyword">const</span> EdgeInsets.<span class="hljs-title function_ invoke__">all</span>(<span class="hljs-number">8.0</span>),<br>                      <span class="hljs-attr">child</span>: <span class="hljs-title function_ invoke__">TextField</span>(<br>                          <span class="hljs-attr">decoration</span>: <span class="hljs-title function_ invoke__">InputDecoration</span>(<br>                            <span class="hljs-attr">hintText</span>: <span class="hljs-string">&#x27;请输入消息&#x27;</span>,<br>                            <span class="hljs-attr">border</span>: InputBorder.none,<br>                          ),<br>                          <span class="hljs-attr">controller</span>:<br>                              <span class="hljs-title function_ invoke__">TextEditingController</span>(<span class="hljs-attr">text</span>: state.message),<br>                          <span class="hljs-attr">onChanged</span>: (value) &#123;<br>                            state.message = value;<br>                          &#125;),<br>                    ),<br>                  ),<br>                  <span class="hljs-title function_ invoke__">IconButton</span>(<br>                    <span class="hljs-attr">icon</span>: <span class="hljs-title function_ invoke__">Icon</span>(Icons.send),<br>                    <span class="hljs-attr">onPressed</span>: state.isRequesting<br>                        ? <span class="hljs-literal">null</span><br>                        : () &#123;<br>                            logic.<span class="hljs-title function_ invoke__">sendMessage</span>(state.message);<br>                          &#125;,<br>                  ),<br>                ],<br>              ),<br>            ),<br>          ],<br>        ),<br>      ),<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该类包含一个<code>ChatLogic</code>实例和一个<code>ChatState</code>实例。在<code>build()</code>方法中，我们使用<code>GetBuilder</code>包装整个聊天界面。这个界面包括一个消息列表和一个输入框，用户可以在其中输入消息并发送给聊天机器人。<code>ListView.builder</code>用于显示历史消息，<code>TextField</code>和<code>IconButton</code>用于接收用户输入并发送消息。在发送消息之前，会检查当前状态是否为请求状态，以避免重复发送请求。</p><p><strong>到这里一个简单的聊天功能就完成了，运行下看看效果吧：</strong></p><p><img src="openai_chat_demo.gif" alt="openai_chat_demo"></p><p><strong>综上所述，本篇介绍了一个使用 Flutter 和 OpenAI API 实现的基于 GPT-3 的聊天机器人。通过实现<code>ApiProvider、ChatLogic</code>和<code>ChatState</code>类，我们能够将 OpenAI API 的功能集成到 Flutter 应用程序中，并实现一个基本的聊天界面。感兴趣的小伙们可以自己试试哈，Demo地址：<a href="https://github.com/smallmarker/OpenAIChat">https://github.com/smallmarker/OpenAIChat</a></strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Retrofit 核心源码分析（三）- Call 逻辑分析和扩展机制</title>
    <link href="/2023/03/10/Retrofit%20%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89-Call-%E9%80%BB%E8%BE%91%E5%88%86%E6%9E%90%E5%92%8C%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/03/10/Retrofit%20%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89-Call-%E9%80%BB%E8%BE%91%E5%88%86%E6%9E%90%E5%92%8C%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p><strong>在前面的两篇文章中，我们已经对 Retrofit 的注解解析、动态代理、网络请求和响应处理机制有了一定的了解。在这篇文章中，我们将深入分析 Retrofit 的 Call 逻辑，并介绍 Retrofit 的扩展机制。</strong></p><h3 id="一、Call-逻辑分析"><a href="#一、Call-逻辑分析" class="headerlink" title="一、Call 逻辑分析"></a>一、Call 逻辑分析</h3><p>Call 是 Retrofit 中最基本的操作单元，它代表一个 HTTP 请求。在 Retrofit 中，我们通过接口定义请求的方式，并通过动态代理生成接口的实现类。这个实现类中的方法都会返回一个 Call 对象，通过这个对象我们可以发起网络请求，并获得响应结果。</p><p>Retrofit 的 Call 逻辑可以用以下代码来描述：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Call</span>&lt;<span class="hljs-title">T</span>&gt; &#123;<br>    <span class="hljs-function">Response&lt;T&gt; <span class="hljs-title">execute</span>() throws IOException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span>(<span class="hljs-params">Callback&lt;T&gt; callback</span>)</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cancel</span>()</span>;<br>    <span class="hljs-function">boolean <span class="hljs-title">isExecuted</span>()</span>;<br>    <span class="hljs-function">boolean <span class="hljs-title">isCanceled</span>()</span>;<br>    <span class="hljs-function">Call&lt;T&gt; <span class="hljs-title">clone</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个接口中，我们可以看到 Retrofit 定义了五个方法，分别是 <code>execute</code>、<code>enqueue</code>、<code>cancel</code>、<code>isExecuted</code>和<code>isCanceled</code>。我们来逐一分析这些方法的作用。</p><h4 id="execute-方法"><a href="#execute-方法" class="headerlink" title="execute 方法"></a>execute 方法</h4><p><code>execute</code>方法用于同步发起 HTTP 请求，当我们调用<code>execute()</code>方法时，它会立即发起网络请求，并且阻塞当前线程直到请求结束，最后返回一个响应对象<code>Response</code>。这种方式适用于简单的网络请求，但不适合于在主线程中执行请求，因为会阻塞 UI 线程。</p><p>以下是<code>execute()</code>方法的部分代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Response&lt;T&gt; <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>  <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>    <span class="hljs-keyword">if</span> (executed) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Already executed.&quot;</span>);<br>    executed = <span class="hljs-literal">true</span>;<br>  &#125;<br>  captureCallStackTrace();<br>  <span class="hljs-keyword">try</span> &#123;<br>    client.dispatcher().executed(<span class="hljs-built_in">this</span>);<br>    Response&lt;T&gt; result = getResponseWithInterceptorChain();<br>    <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;Canceled&quot;</span>);<br>    <span class="hljs-keyword">return</span> result;<br>  &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    <span class="hljs-keyword">throw</span> timeoutExit(e);<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    client.dispatcher().finished(<span class="hljs-built_in">this</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，我们可以看到该方法首先会检查当前请求是否已经执行过，如果已经执行过则会抛出一个异常。然后会将该请求加入到<code>Dispatcher</code>中的执行队列中。接下来会调用<code>getResponseWithInterceptorChain()</code>方法来获取响应结果。如果结果为null，则表示请求已经被取消，否则返回响应结果。最后，会将该请求从执行队列中移除。</p><h4 id="enqueue-方法"><a href="#enqueue-方法" class="headerlink" title="enqueue 方法"></a>enqueue 方法</h4><p><code>enqueue</code>方法用于异步发起 HTTP 请求，它会在后台线程中发起网络请求，并在请求结束后将结果返回到主线程中。因此，<code>enqueue()</code>方法适用于在主线程中执行网络请求。</p><p>以下是<code>enqueue()</code>方法的部分代码：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(Callback&lt;T&gt; callback)</span> </span>&#123;<br>  <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>    <span class="hljs-keyword">if</span> (executed) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Already executed.&quot;</span>);<br>    executed = <span class="hljs-keyword">true</span>;<br>  &#125;<br>  captureCallStackTrace();<br>  client.dispatcher().enqueue(<span class="hljs-keyword">new</span> AsyncCall(callback));<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，我们可以看到该方法首先会检查当前请求是否已经执行过，如果已经执行过则会抛出一个异常。然后会将该请求封装成一个<code>AsyncCall</code>对象，加入到<code>Dispatcher</code>中的异步队列中。</p><p><code>AsyncCall</code>继承自<code>RealCall</code>，它实现了<code>Runnable</code>接口，表示可以在后台线程中执行。在<code>AsyncCall</code>中，我们可以看到它会在后台线程中执行网络请求，并将结果通过<code>Callback</code>回调返回到主线程中。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncCall</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RealCall</span>.<span class="hljs-title">AsyncCall</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Callback</span>&lt;<span class="hljs-type">T</span>&gt; responseCallback;<br><br>  <span class="hljs-type">AsyncCall</span>(<span class="hljs-type">Callback</span>&lt;<span class="hljs-type">T</span>&gt; responseCallback) &#123;<br>    <span class="hljs-keyword">super</span>();<br>    <span class="hljs-keyword">this</span>.responseCallback = responseCallback;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span> <span class="hljs-keyword">protected</span> void execute() &#123;<br>    boolean signalledCallback = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-type">Response</span>&lt;<span class="hljs-type">T</span>&gt; response = getResponseWithInterceptorChain();<br>      <span class="hljs-keyword">if</span> (retryAndFollowUpInterceptor.isCanceled()) &#123;<br>        signalledCallback = <span class="hljs-literal">true</span>;<br>        responseCallback.onFailure(<span class="hljs-type">RealCall</span>.<span class="hljs-keyword">this</span>, <span class="hljs-keyword">new</span> <span class="hljs-type">IOException</span>(<span class="hljs-string">&quot;Canceled&quot;</span>));<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        signalledCallback = <span class="hljs-literal">true</span>;<br>        responseCallback.onResponse(<span class="hljs-type">RealCall</span>.<span class="hljs-keyword">this</span>, response);<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-type">IOException</span> e) &#123;<br>      <span class="hljs-keyword">if</span> (signalledCallback) &#123;<br>        <span class="hljs-comment">// Do not signal the callback twice!</span><br>        <span class="hljs-type">Platform</span>.get().log(<span class="hljs-type">INFO</span>, <span class="hljs-string">&quot;Callback failure for &quot;</span> + toLoggableString(), e);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        responseCallback.onFailure(<span class="hljs-type">RealCall</span>.<span class="hljs-keyword">this</span>, e);<br>      &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      client.dispatcher().finished(<span class="hljs-keyword">this</span>);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span> public <span class="hljs-type">String</span> toString() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">RealCall</span>.<span class="hljs-keyword">this</span>.toString();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>AsyncCall</code>中，首先会调用<code>getResponseWithInterceptorChain()</code>方法来获取响应结果。如果请求被取消，则会调用<code>onFailure()</code>方法将结果返回到主线程中。否则，会调用<code>onResponse()</code>方法将结果返回到主线程中。无论请求成功或失败，都会调用<code>finished()</code>方法将该请求从异步队列中移除。</p><h4 id="cancel-方法"><a href="#cancel-方法" class="headerlink" title="cancel 方法"></a>cancel 方法</h4><p><code>cancel</code>方法用于取消正在执行的请求。如果请求已经完成或已经取消，则该方法不会有任何效果。</p><h4 id="isExecuted-方法"><a href="#isExecuted-方法" class="headerlink" title="isExecuted 方法"></a>isExecuted 方法</h4><p><code>isExecuted</code>方法用于判断请求是否已经执行。如果已经执行，则返回true，否则返回false。</p><h4 id="isCanceled-方法"><a href="#isCanceled-方法" class="headerlink" title="isCanceled 方法"></a>isCanceled 方法</h4><p><code>isCanceled</code>方法用于判断请求是否已经取消。如果已经取消，则返回true，否则返回false。</p><h4 id="clone-方法"><a href="#clone-方法" class="headerlink" title="clone 方法"></a>clone 方法</h4><p><code>clone</code>方法用于创建一个当前 Call 对象的副本。这个方法一般用于发起多次相同的请求。</p><p>以上这些方法就构成了 Retrofit 的 Call 逻辑。在使用 Retrofit 时，我们一般会通过<code>execute</code>或<code>enqueue</code>方法发起 HTTP 请求，并通过传入的<code>Callback</code>对象来处理响应结果。</p><h3 id="二、扩展机制"><a href="#二、扩展机制" class="headerlink" title="二、扩展机制"></a>二、扩展机制</h3><p>Retrofit 是一个非常灵活的网络请求库，它提供了很多扩展机制，让我们可以根据自己的需要来定制请求和响应处理逻辑。下面介绍一些常用的扩展机制。</p><h4 id="Converter"><a href="#Converter" class="headerlink" title="Converter"></a>Converter</h4><p>Converter 用于将 HTTP 请求和响应的数据类型转换成 Java 对象。Retrofit 默认提供了两种 Converter：<code>GsonConverter</code>和<code>JacksonConverter</code>，它们分别使用<code>Gson</code>和<code>Jackson</code>库将数据类型转换成<code>Java</code>对象。如果我们需要使用其他类型的转换库，也可以自定义 Converter 来实现。</p><p>下面是一个自定义 Converter 的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConverter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Converter</span>&lt;ResponseBody, MyObject&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> Gson gson;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyConverter</span><span class="hljs-params">(Gson gson)</span> &#123;<br>        <span class="hljs-built_in">this</span>.gson = gson;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> MyObject <span class="hljs-title function_">convert</span><span class="hljs-params">(ResponseBody value)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> value.string();<br>            <span class="hljs-type">MyObject</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> gson.fromJson(json, MyObject.class);<br>            <span class="hljs-keyword">return</span> obj;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            value.close();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的示例中，我们定义了一个<code>MyConverter</code>类，它实现了<code>Converter</code>接口，用于将<code>ResponseBody</code>类型的响应数据转换成<code>MyObject</code>类型的<code>Java</code>对象。在<code>convert</code>方法中，我们使用自己定义的转换逻辑来实现数据类型的转换。</p><h4 id="Interceptor"><a href="#Interceptor" class="headerlink" title="Interceptor"></a>Interceptor</h4><p>Interceptor 用于对 HTTP 请求进行拦截和处理。在 Retrofit 中，我们可以通过 Interceptor 来对请求添加头信息、对响应进行缓存、打印请求日志等操作。Retrofit 提供了两种 Interceptor：<code>OkHttpInterceptor</code>和<code>RetrofitInterceptor</code>，它们分别用于拦截 OkHttp 的请求和 Retrofit 的请求。我们也可以自定义 Interceptor 来实现自己的拦截逻辑。</p><p>下面是一个自定义 Interceptor 的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Response <span class="hljs-title function_">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 在这里可以对请求进行拦截和处理</span><br>        <span class="hljs-type">Request</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> chain.request();<br>        <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> chain.proceed(request);<br>        <span class="hljs-comment">// 在这里可以对响应进行处理</span><br>        <span class="hljs-keyword">return</span> response;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的示例中，我们定义了一个<code>MyInterceptor</code>类，它实现了<code>Interceptor</code>接口，用于对请求和响应进行拦截和处理。在<code>intercept</code>方法中，我们可以对请求进行处理，然后使用<code>chain.proceed(request)</code>方法将请求传递给下一个拦截器或处理器，最终获得响应结果并进行处理。</p><h4 id="CallAdapter"><a href="#CallAdapter" class="headerlink" title="CallAdapter"></a>CallAdapter</h4><p>CallAdapter 用于将 Call 对象转换成另一种类型的对象。在 Retrofit 中，我们可以通过 CallAdapter 将 Call 对象转换成 RxJava 的 Observable 对象，也可以将 Call 对象转换成 LiveData 对象。Retrofit 提供了两种CallAdapter：<code>RxJavaCallAdapter</code>和<code>LiveDataCallAdapter</code>，它们分别用于将 Call 对象转换成 RxJava 的 Observable 对象和 LiveData 对象。我们也可以自定义 CallAdapter 来实现自己的转换逻辑。</p><p>下面是一个自定义 CallAdapter 的示例：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCallAdapter</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">CallAdapter</span></span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">MyResult</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;<br>    @Override<br>    <span class="hljs-keyword">public</span> Type responseType() &#123;<br>        <span class="hljs-comment">// 返回响应数据的类型</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">ParameterizedTypeImpl</span>(MyResult.class, <span class="hljs-keyword">new</span> <span class="hljs-type">Type</span>[]&#123;T.class&#125;);<br>    &#125;<br><br>    @Override<br>    <span class="hljs-keyword">public</span> MyResult&lt;T&gt; adapt(Call&lt;T&gt; call) &#123;<br>        <span class="hljs-comment">// 在这里可以对Call对象进行处理，并返回自定义的结果对象</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Response&lt;T&gt; response = call.execute();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">MyResult</span>&lt;&gt;(response.body(), response.code(), response.message());<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">MyResult</span>&lt;&gt;(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的示例中，我们定义了一个<code>MyCallAdapter</code>类，它实现了<code>CallAdapter</code>接口，用于将<code>Call</code>对象转换成<code>MyResult</code>对象。在<code>responseType</code>方法中，我们返回了响应数据的类型，它是一个<code>ParameterizedTypeImpl</code>类型的对象，用于表示<code>MyResult&lt;T&gt;</code>类型。在<code>adapt</code>方法中，我们对<code>Call</code>对象进行处理，并返回自定义的<code>MyResult</code>对象，它包含了响应数据、状态码和错误信息。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>在本文中，我们深入分析了 Retrofit 的核心源码，特别是 Call 逻辑的实现细节，以及 Retrofit 的三个扩展机制：Converter、Interceptor 和 CallAdapter。</strong></p><p><strong>通过本文的学习，我们可以更加深入地理解 Retrofit 的工作原理，并可以根据需求自定义扩展 Retrofit 的功能。同时，本文提供了三个扩展机制的示例代码，可以帮助读者更加深入地了解 Retrofit 的扩展机制的使用。</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>Android 源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Retrofit 核心源码分析（二）- 网络请求和响应处理</title>
    <link href="/2023/03/08/Retrofit%20%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E5%A4%84%E7%90%86/"/>
    <url>/2023/03/08/Retrofit%20%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p><strong>在上一篇文章中，我们详细分析了 Retrofit 中的注解解析和动态代理实现，本篇文章将继续深入研究 Retrofit 的核心源码，重点分析 Retrofit 如何进行网络请求和响应处理。</strong></p><h4 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h4><p>在使用 Retrofit 发起网络请求时，我们可以通过定义一个接口并使用 Retrofit 的注解来描述这个接口中的请求，Retrofit 会自动生成一个实现该接口的代理对象。当我们调用这个代理对象的方法时，Retrofit 会根据注解的描述构建一个 Request 对象，并使用 OkHttp 将这个 Request 发送出去。</p><p>在 Retrofit 中，我们可以通过 <code>Retrofit#execute</code> 或 <code>Retrofit#enqueue</code> 方法来发送请求。这两个方法的区别在于，<code>execute</code> 方法会阻塞当前线程直到请求完成，而 <code>enqueue</code> 方法会将请求加入到 OkHttp 的请求队列中，并在请求完成时通过回调通知我们。</p><p>我们先来看一下 <code>execute</code> 方法的实现：</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vbscript"><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-keyword">execute</span>(<span class="hljs-keyword">Call</span>&lt;T&gt; <span class="hljs-keyword">call</span>) throws IOException &#123;<br>  Utils.validateServiceInterface(<span class="hljs-keyword">call</span>.<span class="hljs-built_in">request</span>().tag(), <span class="hljs-keyword">call</span>.<span class="hljs-built_in">request</span>().url().<span class="hljs-keyword">to</span><span class="hljs-built_in">String</span>());<br>  return (T) callAdapter(<span class="hljs-keyword">call</span>, <span class="hljs-keyword">call</span>.<span class="hljs-built_in">request</span>().tag()).adapt(<span class="hljs-keyword">call</span>).<span class="hljs-keyword">execute</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个方法中，首先会对接口进行校验，确保这个接口是有效的。然后我们会根据请求的 Tag 和 URL 来获取适配器<code>callAdapter</code>，并使用适配器来执行请求。</p><p>适配器的作用是将请求的参数适配成 OkHttp 能够识别的形式，并将 OkHttp 的响应适配成我们需要的形式。Retrofit 提供了一系列的适配器，包括 Call 适配器、RxJava 适配器、CompletableFuture 适配器等。</p><p>我们来看一下 <code>callAdapter</code> 方法的实现：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> CallAdapter&lt;?, ?&gt; call<span class="hljs-constructor">Adapter(Call&lt;?&gt; <span class="hljs-params">call</span>, Object <span class="hljs-params">tag</span>)</span> &#123;<br>  Type responseType = call.request<span class="hljs-literal">()</span>.<span class="hljs-keyword">method</span><span class="hljs-literal">()</span>.equals(<span class="hljs-string">&quot;HEAD&quot;</span>)<br>      ? <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Void</span>.</span></span><span class="hljs-keyword">class</span><br>      : get<span class="hljs-constructor">ParameterUpperBound(0, (ParameterizedType)</span> call.request<span class="hljs-literal">()</span>.tag<span class="hljs-literal">()</span>);<br>  return call<span class="hljs-constructor">Adapter(<span class="hljs-params">tag</span>, <span class="hljs-params">responseType</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个方法中，我们首先根据请求的方法来判断响应的类型，如果是 HEAD 方法，那么响应的类型就是 Void；否则我们会通过反射来获取请求的响应类型，并使用这个响应类型来获取适配器。</p><p>获取适配器的方法是 <code>callAdapter</code>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart">public &lt;R, T&gt; CallAdapter&lt;R, T&gt; callAdapter(<span class="hljs-built_in">Object</span> tag, <span class="hljs-built_in">Type</span> returnType) &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">for</span> (CallAdapter.Factory <span class="hljs-keyword">factory</span> : adapterFactories) &#123;<br>    CallAdapter&lt;?, ?&gt; adapter = <span class="hljs-keyword">factory</span>.<span class="hljs-keyword">get</span>(returnType, annotations, <span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">if</span> (adapter != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> (CallAdapter&lt;R, T&gt;) adapter;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个方法中，我们会遍历所有的适配器工厂，尝试获取适配器。在获取适配器时，我们会将请求的响应类型、注解和 Retrofit 实例作为参数传入。每个适配器工厂都会判断这些参数是否符合自己的适配条件，如果符合，就返回一个适配器实例，否则返回 null。在遍历完所有的适配器工厂之后，如果还没有获取到适配器，那么就会抛出一个异常。</p><p>获取到适配器之后，我们就可以使用适配器来执行请求了。在适配器中，我们会将请求参数转换成 OkHttp 的 Request 对象，并将 OkHttp 的 Response 对象转换成我们需要的响应类型。具体的实现可以参考 Retrofit 提供的 <code>CallAdapter</code> 接口。</p><p>对于 <code>enqueue</code> 方法，我们可以先来看一下 <code>enqueue</code> 方法的实现：</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vbscript"><span class="hljs-keyword">public</span> &lt;T&gt; void enqueue(<span class="hljs-keyword">Call</span>&lt;T&gt; <span class="hljs-keyword">call</span>, Callback&lt;T&gt; callback) &#123;<br>  Utils.validateServiceInterface(<span class="hljs-keyword">call</span>.<span class="hljs-built_in">request</span>().tag(), <span class="hljs-keyword">call</span>.<span class="hljs-built_in">request</span>().url().<span class="hljs-keyword">to</span><span class="hljs-built_in">String</span>());<br>  callAdapter(<span class="hljs-keyword">call</span>, <span class="hljs-keyword">call</span>.<span class="hljs-built_in">request</span>().tag()).adapt(<span class="hljs-keyword">call</span>).enqueue(<span class="hljs-keyword">new</span> CallbackRunnable&lt;&gt;(callback));<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个方法中，我们首先进行接口校验，然后根据请求的 Tag 和 URL 来获取适配器，并使用适配器来执行请求。不同的是，在 <code>enqueue</code> 方法中，我们将一个 Callback 对象作为参数传入适配器的 <code>enqueue</code> 方法中，以便在请求完成后回调通知我们。</p><p>在适配器中，我们可以看到 <code>enqueue</code> 方法的实现：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public void enqueue(final Callback&lt;T&gt; callback) &#123;<br>  delegate.enqueue(<span class="hljs-keyword">new</span> Callback&lt;Response&lt;T&gt;&gt;<span class="hljs-literal">()</span> &#123;<br>    @Override public void on<span class="hljs-constructor">Response(Call&lt;Response&lt;T&gt;&gt; <span class="hljs-params">call</span>, Response&lt;Response&lt;T&gt;&gt; <span class="hljs-params">response</span>)</span> &#123;<br>      Response&lt;T&gt; body;<br>      <span class="hljs-keyword">try</span> &#123;<br>        body = response.body<span class="hljs-literal">()</span>;<br>      &#125; catch (Throwable t) &#123;<br>        <span class="hljs-keyword">if</span> (response.code<span class="hljs-literal">()</span><span class="hljs-operator"> == </span><span class="hljs-number">204</span>) &#123;<br>          body = null;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          callback.on<span class="hljs-constructor">Failure(<span class="hljs-params">call</span>, <span class="hljs-params">t</span>)</span>;<br>          return;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (response.is<span class="hljs-constructor">Successful()</span>) &#123;<br>        callback.on<span class="hljs-constructor">Response(<span class="hljs-params">call</span>, Response.<span class="hljs-params">success</span>(<span class="hljs-params">body</span>, <span class="hljs-params">response</span>.<span class="hljs-params">raw</span>()</span>));<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        callback.on<span class="hljs-constructor">Failure(<span class="hljs-params">call</span>, Response.<span class="hljs-params">error</span>(<span class="hljs-params">response</span>.<span class="hljs-params">errorBody</span>()</span>, response.raw<span class="hljs-literal">()</span>));<br>      &#125;<br>    &#125;<br><br>    @Override public void on<span class="hljs-constructor">Failure(Call&lt;Response&lt;T&gt;&gt; <span class="hljs-params">call</span>, Throwable <span class="hljs-params">t</span>)</span> &#123;<br>      callback.on<span class="hljs-constructor">Failure(<span class="hljs-params">call</span>, <span class="hljs-params">t</span>)</span>;<br>    &#125;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个方法中，我们会将传入的 Callback 对象转换成一个 <code>Callback&lt;Response&lt;T&gt;&gt;</code> 对象，并使用这个对象来调用 OkHttp 的 enqueue 方法。在请求完成后，我们会将 OkHttp 的 Response 对象转换成 Retrofit 的 Response 对象，并根据响应码来判断请求的结果。如果响应码表示请求成功，那么我们就调用 Callback 对象的 <code>onResponse</code> 方法；否则就调用 Callback 对象的 <code>onFailure</code> 方法。</p><h4 id="响应处理"><a href="#响应处理" class="headerlink" title="响应处理"></a>响应处理</h4><p>在 Retrofit 中，我们可以通过定义一个接口并使用注解来描述我们期望的请求格式和响应格式。例如，我们可以通过 <code>@GET</code> 注解来描述一个 GET 请求，使用 <code>@Query</code> 注解来描述请求参数，使用 <code>@Body</code> 注解来描述请求体，使用 <code>@Headers</code> 注解来描述请求头等。</p><p>在执行请求时，Retrofit 会根据这些注解来自动生成一个对应的请求对象，并将请求对象转换成 OkHttp 的 Request 对象。在接收响应时，Retrofit 会将 OkHttp 的 Response 对象转换成一个对应的响应对象，并将响应对象中的数据转换成我们需要的数据类型。这些转换工作是通过 Retrofit 的转换器来完成的，Retrofit 中默认提供了两个转换器：<code>GsonConverterFactory</code> 和 <code>JacksonConverterFactory</code>。我们也可以自定义一个转换器来实现我们期望的数据转换。</p><p>在 Retrofit 类的构造方法中，我们可以看到 Retrofit 默认使用了 <code>Platform.get()</code> 方法来获取当前运行平台的默认转换器工厂，并将其添加到 <code>converterFactories</code> 中。然后，我们可以使用 <code>addConverterFactory</code> 方法来添加自定义的转换器工厂。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Retrofit</span>(<span class="hljs-params">Builder builder</span>)</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">if</span> (builder.converterFactories == <span class="hljs-literal">null</span>) &#123;<br>    converterFactories.<span class="hljs-keyword">add</span>(Platform.<span class="hljs-keyword">get</span>().defaultConverterFactory());<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    converterFactories.addAll(builder.converterFactories);<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Platform</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>  Converter.<span class="hljs-function">Factory <span class="hljs-title">defaultConverterFactory</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>execute</code>方法中，我们会调用适配器的 adapt 方法来执行请求，并将返回的 Call 对象转换成一个响应对象。在转换过程中，我们会根据响应类型来选择对应的转换器来进行转换。具体的转换实现可以参考 Retrofit 提供的 <code>Converter</code> 接口和 <code>Converter.Factory</code> 接口。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs scala">public &lt;<span class="hljs-type">T</span>&gt; <span class="hljs-type">T</span> execute(<span class="hljs-type">Call</span>&lt;<span class="hljs-type">T</span>&gt; call) <span class="hljs-keyword">throws</span> <span class="hljs-type">IOException</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-type">Response</span>&lt;<span class="hljs-type">T</span>&gt; response = call.execute();<br>  <span class="hljs-keyword">if</span> (response.isSuccessful()) &#123;<br>    <span class="hljs-keyword">return</span> response.body();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-type">Converter</span>&lt;<span class="hljs-type">ResponseBody</span>, <span class="hljs-type">ErrorResponse</span>&gt; converter = retrofit.responseBodyConverter(<br>        <span class="hljs-type">ErrorResponse</span>.<span class="hljs-keyword">class</span>, <span class="hljs-keyword">new</span> <span class="hljs-type">Annotation</span>[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">ApiException</span>(converter.convert(response.errorBody()));<br>  &#125;<br>&#125;<br><br><span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">&quot;unchecked&quot;</span>) <span class="hljs-comment">// Single-interface proxy creation guarded by parameter safety.</span><br>public &lt;<span class="hljs-type">T</span>&gt; <span class="hljs-type">T</span> adapt(<span class="hljs-type">Call</span>&lt;<span class="hljs-type">T</span>&gt; call) &#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">T</span>) <span class="hljs-keyword">new</span> <span class="hljs-type">OkHttpCall</span>&lt;&gt;(requestFactory, callFactory, converter, call);<br>&#125;<br><br>public &lt;<span class="hljs-type">T</span>&gt; <span class="hljs-type">Converter</span>&lt;<span class="hljs-type">ResponseBody</span>, <span class="hljs-type">T</span>&gt; responseBodyConverter(<span class="hljs-type">Type</span> <span class="hljs-class"><span class="hljs-keyword">type</span>, <span class="hljs-title">Annotation</span>[] <span class="hljs-title">annotations</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> nextResponseBodyConverter(<span class="hljs-literal">null</span>, <span class="hljs-class"><span class="hljs-keyword">type</span>, <span class="hljs-title">annotations</span>)</span>;<br>&#125;<br><br>public &lt;<span class="hljs-type">T</span>&gt; <span class="hljs-type">Converter</span>&lt;<span class="hljs-type">ResponseBody</span>, <span class="hljs-type">T</span>&gt; nextResponseBodyConverter(<br>    <span class="hljs-meta">@Nullable</span> <span class="hljs-type">Converter</span>.<span class="hljs-type">Factory</span> skipPast, <span class="hljs-type">Type</span> <span class="hljs-class"><span class="hljs-keyword">type</span>, <span class="hljs-title">Annotation</span>[] <span class="hljs-title">annotations</span>) </span>&#123;<br>  <span class="hljs-type">Objects</span>.requireNonNull(<span class="hljs-class"><span class="hljs-keyword">type</span>, &quot;<span class="hljs-title">type</span> <span class="hljs-title">==</span> <span class="hljs-title">null</span>&quot;)</span>;<br>  <span class="hljs-type">Objects</span>.requireNonNull(annotations, <span class="hljs-string">&quot;annotations == null&quot;</span>);<br><br>  int start = converterFactories.indexOf(skipPast) + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (int i = start, count = converterFactories.size(); i &lt; count; i++) &#123;<br>    <span class="hljs-type">Converter</span>&lt;<span class="hljs-type">ResponseBody</span>, ?&gt; converter =<br>        converterFactories.get(i).responseBodyConverter(<span class="hljs-class"><span class="hljs-keyword">type</span>, <span class="hljs-title">annotations</span>, <span class="hljs-title">this</span>)</span>;<br>    <span class="hljs-keyword">if</span> (converter != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> (<span class="hljs-type">Converter</span>&lt;<span class="hljs-type">ResponseBody</span>, <span class="hljs-type">T</span>&gt;) converter;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">IllegalArgumentException</span>(<br>      <span class="hljs-string">&quot;Could not locate ResponseBody converter for &quot;</span> + <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">+</span> &quot; <span class="hljs-keyword">with</span> <span class="hljs-title">annotations</span> &quot; <span class="hljs-title">+</span> <span class="hljs-title">Arrays</span>.<span class="hljs-title">toString</span>(<span class="hljs-params">annotations</span>))</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上是 Retrofit 中处理响应的核心代码。当我们执行一个请求时，Retrofit 会先将请求转换成 OkHttp 的 Request 对象并发送出去，然后等待响应返回。当响应返回时，Retrofit 会将响应转换成一个响应对象，并将响应对象中的数据转换成我们期望的数据类型。这个过程中，我们可以使用 Retrofit 提供的转换器来自定义数据的转换规则。</p><p>下面是一个示例，演示了如何使用 Retrofit 来发送一个 GET 请求并将响应中的 JSON 数据转换成一个 Java 对象：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> interface ApiService &#123;<br>  @<span class="hljs-keyword">GET</span>(&quot;users/&#123;user&#125;/repos&quot;)<br>  <span class="hljs-keyword">Call</span>&lt;List&lt;Repo&gt;&gt; listRepos(@Path(&quot;user&quot;) String <span class="hljs-keyword">user</span>);<br>&#125;<br><br>Retrofit retrofit = <span class="hljs-built_in">new</span> Retrofit.Builder()<br>    .baseUrl(&quot;https://api.github.com/&quot;)<br>    .addConverterFactory(GsonConverterFactory.<span class="hljs-keyword">create</span>())<br>    .build();<br><br>ApiService apiService = retrofit.<span class="hljs-keyword">create</span>(ApiService.<span class="hljs-keyword">class</span>);<br><span class="hljs-keyword">Call</span>&lt;List&lt;Repo&gt;&gt; <span class="hljs-keyword">call</span> = apiService.listRepos(&quot;smallmarker&quot;);<br>List&lt;Repo&gt; repos = <span class="hljs-keyword">call</span>.<span class="hljs-keyword">execute</span>().body();<br></code></pre></td></tr></table></figure><p>在上面的示例中，我们首先使用 Retrofit 构建器创建一个 Retrofit 实例，并指定了请求的基础 URL 和转换器工厂。然后，我们通过调用 <code>create</code> 方法来创建一个 <code>ApiService</code> 的代理对象。最后，我们调用 <code>listRepos</code> 方法来发送一个 GET 请求。</p><p>在上面的示例中，我们使用了 Retrofit 的 <code>GsonConverterFactory</code> 来将响应体中的 JSON 数据转换成 Java 对象。具体实现可以查看 Retrofit 提供的 <code>GsonConverterFactory</code> 类。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> final <span class="hljs-keyword">class</span> <span class="hljs-title class_">GsonConverterFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Converter.Factory</span> &#123;<br>  <span class="hljs-keyword">private</span> final <span class="hljs-title class_">Gson</span> gson;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-title class_">GsonConverterFactory</span>(<span class="hljs-title class_">Gson</span> gson) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">gson</span> = gson;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">GsonConverterFactory</span> <span class="hljs-title function_">create</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">create</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Gson</span>());<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">GsonConverterFactory</span> <span class="hljs-title function_">create</span>(<span class="hljs-params">Gson gson</span>) &#123;<br>    <span class="hljs-keyword">if</span> (gson == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;gson == null&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GsonConverterFactory</span>(gson);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-meta">@Nullable</span> <span class="hljs-title class_">Converter</span>&lt;<span class="hljs-title class_">ResponseBody</span>, ?&gt; <span class="hljs-title function_">responseBodyConverter</span>(<span class="hljs-params">Type <span class="hljs-keyword">type</span>, Annotation[] annotations, Retrofit retrofit</span>) &#123;<br>    <span class="hljs-title class_">TypeAdapter</span>&lt;?&gt; adapter = gson.<span class="hljs-title function_">getAdapter</span>(<span class="hljs-title class_">TypeToken</span>.<span class="hljs-title function_">get</span>(<span class="hljs-keyword">type</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GsonResponseBodyConverter</span>&lt;&gt;(gson, adapter);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-meta">@Nullable</span> <span class="hljs-title class_">Converter</span>&lt;?, <span class="hljs-title class_">RequestBody</span>&gt; <span class="hljs-title function_">requestBodyConverter</span>(<span class="hljs-params">Type <span class="hljs-keyword">type</span>, Annotation[] parameterAnnotations,</span><br><span class="hljs-params">                                                                  Annotation[] methodAnnotations, Retrofit retrofit</span>) &#123;<br>    <span class="hljs-title class_">TypeAdapter</span>&lt;?&gt; adapter = gson.<span class="hljs-title function_">getAdapter</span>(<span class="hljs-title class_">TypeToken</span>.<span class="hljs-title function_">get</span>(<span class="hljs-keyword">type</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GsonRequestBodyConverter</span>&lt;&gt;(gson, adapter);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，<code>GsonConverterFactory</code> 继承了 Retrofit 的 <code>Converter.Factory</code> 类，并重写了其中的 <code>responseBodyConverter</code> 方法和 <code>requestBodyConverter</code> 方法。在 <code>responseBodyConverter</code> 方法中，我们将响应体中的 JSON 数据转换成 Java 对象，而在 <code>requestBodyConverter</code> 方法中，我们将 Java 对象转换成请求体中的 JSON 数据。</p><p>除了 <code>GsonConverterFactory</code> 以外，Retrofit 还提供了其他的转换器，如 <code>JacksonConverterFactory、MoshiConverterFactory</code> 等，我们可以根据需要选择适合自己的转换器。</p><p>总的来说，Retrofit 中网络请求和响应处理的核心代码非常简洁明了。我们只需要通过定义接口来描述请求和响应，然后使用 Retrofit 的动态代理机制来将接口转换成一个实际的实现类，并通过 Retrofit 的配置来指定请求和响应的转换器即可。这种方式大大简化了网络请求的流程，使得我们可以更加专注于业务逻辑的处理。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android 源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Retrofit 核心源码分析（一）- 注解解析和动态代理</title>
    <link href="/2023/03/07/Retrofit%20%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89-%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <url>/2023/03/07/Retrofit%20%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89-%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p><strong>Retrofit是目前Android平台上比较流行的网络请求框架之一，它提供了一种简洁、灵活的方式来处理HTTP请求和响应。Retrofit的设计目的是使网络请求的代码更加容易编写和阅读，同时还提供了许多有用的特性，如注解解析、动态代理等。在本文中，我们将对Retrofit的注解解析和动态代理进行详细的分析。</strong></p><h4 id="注解解析"><a href="#注解解析" class="headerlink" title="注解解析"></a>注解解析</h4><p>在使用Retrofit时，我们通常会定义一个接口，该接口用于描述我们要请求的API接口。在这个接口中，我们可以使用注解来描述API的各个方面，如HTTP方法、请求URL、请求参数等。Retrofit会根据这些注解来生成相应的网络请求代码。下面是一个示例：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">interface</span> <span class="hljs-selector-tag">GitHubService</span> &#123;<br>    <span class="hljs-variable">@GET</span>(<span class="hljs-string">&quot;users/&#123;user&#125;/repos&quot;</span>)<br>    fun listRepos(<span class="hljs-variable">@Path</span>(<span class="hljs-string">&quot;user&quot;</span>) <span class="hljs-attribute">user</span>: String): Call&lt;List&lt;Repo&gt;&gt;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个示例中，@GET注解表示这是一个HTTP GET请求，”users/{user}/repos”表示请求的URL，@Path(“user”)表示请求URL中的参数。Retrofit会解析这些注解，并生成相应的网络请求代码。</p><p>Retrofit中的注解解析是通过Retrofit.Builder中的retrofit2.Retrofit#create方法实现的。这个方法会返回一个代理对象，该代理对象会在调用接口方法时解析注解并生成相应的网络请求。</p><p>下面是retrofit2.Retrofit#create方法的核心代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Utils</span>.</span></span>validate<span class="hljs-constructor">ServiceInterface(<span class="hljs-params">service</span>)</span>;<br>    <span class="hljs-keyword">if</span> (validateEagerly) &#123;<br>        eagerly<span class="hljs-constructor">ValidateMethods(<span class="hljs-params">service</span>)</span>;<br>    &#125;<br>    return (T) <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Proxy</span>.</span></span><span class="hljs-keyword">new</span><span class="hljs-constructor">ProxyInstance(<span class="hljs-params">service</span>.<span class="hljs-params">getClassLoader</span>()</span>, <span class="hljs-keyword">new</span> Class&lt;?&gt;<span class="hljs-literal">[]</span> &#123; service &#125;,<br>            <span class="hljs-keyword">new</span> <span class="hljs-constructor">InvocationHandler()</span> &#123;<br>                <span class="hljs-keyword">private</span> final Platform platform = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Platform</span>.</span></span>get<span class="hljs-literal">()</span>;<br><br>                @Override<br>                public Object invoke(Object proxy, Method <span class="hljs-keyword">method</span>, Object<span class="hljs-literal">[]</span> args)<br>                        throws Throwable &#123;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">method</span>.get<span class="hljs-constructor">DeclaringClass()</span><span class="hljs-operator"> == </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span><span class="hljs-keyword">class</span>) &#123;<br>                        return <span class="hljs-keyword">method</span>.invoke(this, args);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (platform.is<span class="hljs-constructor">DefaultMethod(<span class="hljs-params">method</span>)</span>) &#123;<br>                        return platform.invoke<span class="hljs-constructor">DefaultMethod(<span class="hljs-params">method</span>, <span class="hljs-params">service</span>, <span class="hljs-params">proxy</span>, <span class="hljs-params">args</span>)</span>;<br>                    &#125;<br>                    ServiceMethod&lt;Object, Object&gt; serviceMethod =<br>                            (ServiceMethod&lt;Object, Object&gt;) load<span class="hljs-constructor">ServiceMethod(<span class="hljs-params">method</span>)</span>;<br>                    OkHttpCall&lt;Object&gt; okHttpCall = <span class="hljs-keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);<br>                    return serviceMethod.callAdapter.adapt(okHttpCall);<br>                &#125;<br>            &#125;);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>该方法首先会验证接口是否满足要求，然后会返回一个代理对象。这个代理对象实现了接口中的所有方法，并在调用方法时解析注解并生成相应的网络请求。</p><p>我们可以看到，代理对象的实现是通过java.lang.reflect.Proxy类实现的。Proxy.newProxyInstance方法会返回一个代理对象，该代理对象实现了指定接口中的所有方法。当我们调用代理对象的方法时，代理对象会调用InvocationHandler.invoke方法，该方法中实现了注解解析和网络请求的生成。</p><p>在InvocationHandler.invoke方法中，首先会判断是否调用了Object类的方法，如果是，则直接返回该方法的执行结果。如果不是，则进一步判断是否调用了接口的默认方法，如果是，则使用Platform类调用默认方法。否则，就调用loadServiceMethod方法来解析注解并生成网络请求。</p><p>loadServiceMethod方法会首先从缓存中获取ServiceMethod对象，如果缓存中没有，则创建一个新的ServiceMethod对象。ServiceMethod对象包含了网络请求的相关信息，如HTTP方法、请求URL、请求参数等。ServiceMethod对象的创建是通过ServiceMethod.Builder类实现的，该类会解析接口方法上的注解并生成相应的网络请求。</p><p>下面是ServiceMethod.Builder类的核心代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> ServiceMethod <span class="hljs-title">build</span>()</span> &#123;<br>    callAdapter = createCallAdapter();<br>    responseType = callAdapter.responseType();<br>    <span class="hljs-keyword">if</span> (responseType == Response.<span class="hljs-keyword">class</span> || responseType == okhttp3.Response.<span class="hljs-keyword">class</span>) &#123;<br>        <span class="hljs-keyword">throw</span> methodError(<span class="hljs-string">&quot;&#x27;&quot;</span><br>                + Utils.getRawType(responseType).getName()<br>                + <span class="hljs-string">&quot;&#x27; is not a valid response body type. Did you mean ResponseBody?&quot;</span>);<br>    &#125;<br>    responseConverter = createResponseConverter();<br>    RequestFactory requestFactory = createRequestFactory();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ServiceMethod&lt;&gt;(requestFactory, callAdapter, responseConverter);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在ServiceMethod.Builder类中，首先会创建一个CallAdapter对象，该对象用于处理网络请求的结果。然后会检查responseType是否是Response或okhttp3.Response类型，如果是，则抛出异常。接下来，会创建一个ResponseConverter对象，该对象用于将网络请求的结果转换成Java对象。最后，会创建一个RequestFactory对象，该对象用于创建okhttp3.Request对象。</p><p>ServiceMethod对象包含了网络请求的相关信息，包括RequestFactory对象、CallAdapter对象和ResponseConverter对象。OkHttpCall对象则负责执行网络请求，并将结果传递给CallAdapter对象进行处理。CallAdapter对象最终将结果转换成Java对象并返回给调用者。</p><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>在前面的代码中，我们已经看到了动态代理的使用。在Retrofit中，我们使用动态代理来实现注解解析和网络请求的生成。动态代理是一种机制，通过它我们可以在运行时创建一个代理对象，该代理对象会代替原始对象来执行方法调用。</p><p>在Retrofit中，我们使用动态代理来创建一个实现接口的代理对象。当我们调用代理对象的方法时，代理对象会调用InvocationHandler.invoke方法，该方法中实现了注解解析和网络请求的生成。因此，我们可以将网络请求的代码封装在接口中，使得我们的代码更加简洁和易于阅读。</p><p>下面是一个使用动态代理的简单示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> java.lang.reflect.*<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HelloWorld</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldImpl</span> : <span class="hljs-type">HelloWorld &#123;</span></span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;Hello, world!&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> proxy = Proxy.newProxyInstance(<br>        DynamicProxyExample::<span class="hljs-keyword">class</span>.java.classLoader,<br>        arrayOf(HelloWorld::<span class="hljs-keyword">class</span>.java),<br>        <span class="hljs-keyword">object</span> : InvocationHandler &#123;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> target: HelloWorld = HelloWorldImpl()<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">invoke</span><span class="hljs-params">(proxy: <span class="hljs-type">Any</span>?, method: <span class="hljs-type">Method</span>?, args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">out</span> <span class="hljs-type">Any</span>&gt;?)</span></span>: Any? &#123;<br>                println(<span class="hljs-string">&quot;Before method execution...&quot;</span>)<br>                <span class="hljs-keyword">val</span> result = method?.invoke(target, *(args ?: emptyArray()))<br>                println(<span class="hljs-string">&quot;After method execution...&quot;</span>)<br>                <span class="hljs-keyword">return</span> result<br>            &#125;<br>        &#125;<br>    ) <span class="hljs-keyword">as</span> HelloWorld<br>    proxy.sayHello()<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个<code>HelloWorld</code>接口和一个<code>HelloWorldImpl</code>实现类。然后，我们使用动态代理创建了一个代理对象，该代理对象实现了<code>HelloWorld</code>接口。在<code>InvocationHandler</code>的<code>invoke</code>方法中，我们首先输出一行日志，然后调用<code>HelloWorldImpl</code>对象的<code>sayHello</code>方法，最后再输出一行日志。当我们调用代理对象的<code>sayHello</code>方法时，代理对象会调用<code>InvocationHandler.invoke</code>方法，从而实现了在方法执行前后输出日志的功能。动态代理是一种非常强大的机制，可以用于实现很多功能，如性能分析、日志记录、事务管理等。在Retrofit中，我们使用动态代理来实现注解解析和网络请求的生成，从而使得我们的代码更加简洁和易于阅读。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android 源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 流式布局TagFlowLayout</title>
    <link href="/2022/07/25/Android-%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80TagFlowLayout/"/>
    <url>/2022/07/25/Android-%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80TagFlowLayout/</url>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>这是一个Android流式布局，根据鸿翔大神之前写的<a href="https://github.com/hongyangAndroid/FlowLayout">FlowLayout</a>设计思路结合<code>Material</code>库中的<code>ChipGroup</code>设计架构衍生而来，全新的流式布局<a href="https://github.com/smallmarker/TagFlowLayout">TagFlowLayout</a>组件</strong></p><h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><p><img src="tagflowlayout_demo.gif" alt="tagflowlayout_demo"></p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="setter"><a href="#setter" class="headerlink" title="setter"></a>setter</h4><table><thead><tr><th align="center">方法名称</th><th align="center">作用</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center"><code>setTagSpacingHorizontal(@Dimension tagSpacingHorizontal: Int)</code></td><td align="center">Tag间的水平间距</td><td align="center"><code>setTagSpacingHorizontal(24)</code></td></tr><tr><td align="center"><code>setTagSpacingVertical(@Dimension tagSpacingVertical: Int)</code></td><td align="center">Tag间的垂直间距</td><td align="center"><code>setTagSpacingVertical(24)</code></td></tr><tr><td align="center"><code>setSingleLine(singleLine: Boolean)</code></td><td align="center">是否开启单行模式（默认false）</td><td align="center"><code>setSingleLine(true)</code></td></tr><tr><td align="center"><code>setSingleSelection(singleSelection: Boolean)</code></td><td align="center">是否开启单选模式（默认false）</td><td align="center"><code>setSingleSelection(true)</code></td></tr><tr><td align="center"><code>setSelectionRequired(selectionRequired: Boolean)</code></td><td align="center">是否为必选项（默认false</td><td align="center"><code>setSelectionRequired(true)</code></td></tr><tr><td align="center"><code>setSelectMax(selectMax: Int)</code></td><td align="center">最大选择数量（&lt;=0为无效值</td><td align="center"><code>setSelectMax(10)</code></td></tr><tr><td align="center"><code>setOnTagClickListener(tagClickListener: TagClickListener)</code></td><td align="center">设置Tag点击事件</td><td align="center"><code>setOnTagClickListener &#123; view, position, parent -&gt; &#125;</code></td></tr><tr><td align="center"><code>setCheckedChangedListener(checkedChangedListener: CheckedChangedListener)</code></td><td align="center">设置Tag状态变更监听事件</td><td align="center"><code>setCheckedChangedListener &#123; group, checkedIds -&gt; &#125;</code></td></tr></tbody></table><h4 id="getter"><a href="#getter" class="headerlink" title="getter"></a>getter</h4><table><thead><tr><th align="center">方法名称</th><th align="center">作用</th><th align="center">返回类型</th></tr></thead><tbody><tr><td align="center"><code>isSelectMax()</code></td><td align="center">是否达到最大的选择数量</td><td align="center"><code>Boolean</code></td></tr><tr><td align="center"><code>clearCheck()</code></td><td align="center">清除所有选中数据</td><td align="center"><code>void</code></td></tr><tr><td align="center"><code>getCheckedTagOrder()</code></td><td align="center">获取选中单选下标</td><td align="center"><code>Int</code></td></tr><tr><td align="center"><code>getCheckedTagOrders()</code></td><td align="center">获取选中集合下标组</td><td align="center"><code>List&lt;Int&gt;</code></td></tr></tbody></table><h4 id="Attributes属性"><a href="#Attributes属性" class="headerlink" title="Attributes属性"></a>Attributes属性</h4><table><thead><tr><th align="center">属性名称</th><th align="center">作用</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center"><code>app:tagSpacing</code></td><td align="center">Tag间的间距</td><td align="center"><code>app:tagSpacing=&quot;24dp&quot;</code></td></tr><tr><td align="center"><code>app:tagSpacingHorizontal</code></td><td align="center">Tag间的水平间距</td><td align="center"><code>app:tagSpacingHorizontal=&quot;24dp&quot;</code></td></tr><tr><td align="center"><code>app:tagSpacingVertical</code></td><td align="center">Tag间的垂直间距</td><td align="center"><code>app:tagSpacingVertical=&quot;24dp&quot;</code></td></tr><tr><td align="center"><code>app:singleLine</code></td><td align="center">是否开启单行模式（默认false）</td><td align="center"><code>app:singleLine=&quot;true&quot;</code></td></tr><tr><td align="center"><code>app:singleSelection</code></td><td align="center">是否开启单选模式（默认false）</td><td align="center"><code>app:是否开启单选模式=&quot;true&quot;</code></td></tr><tr><td align="center"><code>app:selectionRequired</code></td><td align="center">是否为必选项（默认false）</td><td align="center"><code>app:selectionRequired=&quot;true&quot;</code></td></tr><tr><td align="center"><code>app:selectMax</code></td><td align="center">最大选择数量（&lt;=0为无效值）</td><td align="center"><code>app:selectMax=&quot;10&quot;</code></td></tr></tbody></table><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">dependencies &#123;<br>    <span class="hljs-keyword">implementation</span> <span class="hljs-string">&#x27;io.github.smallmarker:tagflowlayout:1.0&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;com.smallmarker.tagflowlayout.TagFlowLayout<br>            android:<span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;@+id/tag_flow_layout&quot;</span><br>            android:<span class="hljs-attribute">layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span><br>            android:<span class="hljs-attribute">layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span><br>            app:<span class="hljs-attribute">tagSpacing</span>=<span class="hljs-string">&quot;16dp&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><h3 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h3><h4 id="方法属性"><a href="#方法属性" class="headerlink" title="方法属性"></a>方法属性</h4><ul><li>创建Adapter：<code>TagFlowAdapter.create(dataList)</code></li><li>设置Tag：<code>setView(parent: TagFlowLayout, position: Int, t: T)</code></li><li>设置Tag状态：<code>setChecked(position: Int, t: T)</code></li><li>监听状态变化：<code>setCheckedChanged(isChecked: Boolean, position: Int, view: View)</code></li><li>刷新适配器：<code>notifyDataSetChange()</code></li></ul><h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h4><ul><li><strong>设置数据</strong></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 设置Adapter</span><br>binding<span class="hljs-selector-class">.tagFlowLayout</span><span class="hljs-selector-class">.adapter</span> = TagFlowAdapter<span class="hljs-selector-class">.create</span>(dataList) &#123;<br>    setView &#123; parent, <span class="hljs-attribute">position</span>, t -&gt;<br>        <span class="hljs-built_in">TextView</span>(parent.context)<span class="hljs-selector-class">.apply</span> &#123;<br>            text = t<br>            <span class="hljs-built_in">setBackgroundResource</span>(R<span class="hljs-selector-class">.drawable</span>.bg_tag_selector)<br>            <span class="hljs-built_in">setPadding</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>选中状态</strong></li></ul><p>支持通过<code>state=checked</code>来控制选中和取消</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">selector</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">android:state_checked</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">shape</span> <span class="hljs-attr">android:shape</span>=<span class="hljs-string">&quot;rectangle&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">corners</span> <span class="hljs-attr">android:radius</span>=<span class="hljs-string">&quot;6dp&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">stroke</span> <span class="hljs-attr">android:width</span>=<span class="hljs-string">&quot;1.2dp&quot;</span> <span class="hljs-attr">android:color</span>=<span class="hljs-string">&quot;#374D9D&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">shape</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">shape</span> <span class="hljs-attr">android:shape</span>=<span class="hljs-string">&quot;rectangle&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">corners</span> <span class="hljs-attr">android:radius</span>=<span class="hljs-string">&quot;6dp&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">stroke</span> <span class="hljs-attr">android:width</span>=<span class="hljs-string">&quot;1.2dp&quot;</span> <span class="hljs-attr">android:color</span>=<span class="hljs-string">&quot;#C4C7D1&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">shape</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">selector</span>&gt;</span><br></code></pre></td></tr></table></figure><p>也可以自己在<code>Adapter</code> 的<code>setCheckedChanged</code>处理显示</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">setCheckedChanged &#123; isChecked, <span class="hljs-attribute">position</span>, view -&gt;<br>                Log<span class="hljs-selector-class">.d</span>(<span class="hljs-string">&quot;TAG&quot;</span>, <span class="hljs-string">&quot;当前TAG状态：$&#123;isChecked&#125;, $&#123;position&#125;&quot;</span>)<br>                view<span class="hljs-selector-class">.setBackgroundColor</span>(<span class="hljs-keyword">if</span> (isChecked) &#123;<br>                    Color<span class="hljs-selector-class">.RED</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    Color<span class="hljs-selector-class">.GRAY</span><br>                &#125;)<br>            &#125;<br></code></pre></td></tr></table></figure><ul><li><strong>事件</strong></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 点击事件</span><br>binding<span class="hljs-selector-class">.tagFlowLayout</span><span class="hljs-selector-class">.setOnTagClickListener</span> &#123; view, <span class="hljs-attribute">position</span>, parent -&gt;<br>    Log<span class="hljs-selector-class">.d</span>(<span class="hljs-string">&quot;TAG&quot;</span>, <span class="hljs-string">&quot;当前选中TAG： $&#123;position&#125;&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 状态监听</span><br>binding<span class="hljs-selector-class">.tagFlowLayout</span><span class="hljs-selector-class">.setCheckedChangedListener</span> &#123; group, checkedIds -&gt;<br>    binding<span class="hljs-selector-class">.tvTip</span><span class="hljs-selector-class">.text</span> = <span class="hljs-string">&quot;当前选中TAG序号：$&#123;checkedIds&#125;&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>偶然发现<code>material</code>库中<code>chip</code>组件，其通过<code>ChipGroup</code>实现流式布局的设计，加上很早之前有用过鸿神的<code>FlowLayout</code>库，所以就在此基础上写了一个新的流式布局组件，该组件在类的命名上还是沿用了鸿神之前的<code>FlowLayout</code>，为了不依赖<code>material</code>库的较高版本的限制，故将需要用到的类抽取使用，做兼容处理</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>Android 组件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android AGP升级后导致APK体积增大</title>
    <link href="/2022/06/10/Android-AGP%E5%8D%87%E7%BA%A7%E5%90%8E%E5%AF%BC%E8%87%B4APK%E4%BD%93%E7%A7%AF%E5%A2%9E%E5%A4%A7/"/>
    <url>/2022/06/10/Android-AGP%E5%8D%87%E7%BA%A7%E5%90%8E%E5%AF%BC%E8%87%B4APK%E4%BD%93%E7%A7%AF%E5%A2%9E%E5%A4%A7/</url>
    
    <content type="html"><![CDATA[<p><strong>项目AGP升级至7.0+后发现打出来release包的体积比之前增加近一倍，经过查询官方文档得知在AGP3.6.0时的行为变更上：默认情况下，原生库以未压缩的形式打包。</strong></p><p>在构建应用时，插件现在默认会将 <code>extractNativeLibs</code> 设置为<code> &quot;false&quot;</code>也就是说，您的原生库将保持页面对齐状态并以未压缩的形式打包。虽然这样会增加上传大小，但您的用户会从以下优势中受益：</p><ul><li>减小应用安装大小，因为平台可以直接从已安装的 APK 访问原生库，而无需创建库的副本。</li><li>减小下载文件大小，因为在 APK 或 <code>Android App Bundle</code> 中添加未压缩的原生库通常可提高 Play 商店的压缩率。</li></ul><p>如果您希望 <code>Android Gradle</code> 插件改为打包压缩后的原生库，请在应用的清单中添加以下代码：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-built_in">application</span><br>    android:extractNativeLibs=<span class="hljs-string">&quot;true&quot;</span><br>    ... &gt;<br>&lt;/<span class="hljs-built_in">application</span>&gt;<br></code></pre></td></tr></table></figure><p><strong>但是从 AGP 4.2.0 开始，<code>extractNativeLibs</code> 清单属性已被 DSL 选项 <code>useLegacyPackaging</code> 取代。 您应该使用应用的 <code>build.gradle</code> 文件中的 <code>useLegacyPackaging</code>（而非清单文件中的 <code>extractNativeLibs</code>）来配置原生库压缩行为：</strong></p><h5 id="使用-DSL-打包压缩后的原生库"><a href="#使用-DSL-打包压缩后的原生库" class="headerlink" title="使用 DSL 打包压缩后的原生库"></a>使用 DSL 打包压缩后的原生库</h5><p>官方建议以未压缩的形式打包原生库，因为这会减小应用安装大小，缩减应用下载大小，并缩短用户的应用加载时间。不过，如果您希望 <code>Android Gradle</code> 插件在构建应用时打包压缩后的原生库，请在应用的 <code>build.gradle</code> 文件中将 <code>useLegacyPackaging</code>设置为 <code>true</code>：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">android</span> &#123;<br>    <span class="hljs-keyword">packagingOptions</span> &#123;<br>        <span class="hljs-keyword">jniLibs</span> &#123;<br>            useLegacyPackaging <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：<code>useLegacyPackaging</code> 标记会替换 <code>extractNativeLibs</code> 清单属性。默认情况下，原生库以未压缩的形式打包。</strong></p><p>官方文档参考：</p><p><a href="https://developer.android.com/studio/releases/gradle-plugin?buildsystem=ndk-build#extractNativeLibs">https://developer.android.com/studio/releases/gradle-plugin?buildsystem=ndk-build#extractNativeLibs</a></p><p><a href="https://developer.android.com/studio/releases/gradle-plugin?buildsystem=ndk-build#compress-native-libs-dsl">https://developer.android.com/studio/releases/gradle-plugin?buildsystem=ndk-build#compress-native-libs-dsl</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Android 奇遇记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
